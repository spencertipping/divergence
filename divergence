#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

meta::meta('bootstrap::initialization', <<'__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU');

__47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU

meta::meta('datatypes::bootstrap', <<'__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM');
meta::define_form 'bootstrap', sub {};
__guYWiOv4zBmdrlI3k3sW7f/q/xsX38Xvzz0dwwLCIRM

meta::meta('datatypes::code', <<'__VqQsjlm+HucvTRVlIGc8oi++EzzNq+rwy5bhKzunE8A');
meta::define_form 'code', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "code::$name";
  *{$name} = sub {
    return edit("code::$name")     unless defined $_[0];
    return unlit("code::$name")    if $_[0] eq 'unlit';
    return retrieve("code::$name") if $_[0] eq 'cat';
  };
};
__VqQsjlm+HucvTRVlIGc8oi++EzzNq+rwy5bhKzunE8A

meta::meta('datatypes::data', <<'__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U');
meta::define_form 'data', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "data::$name";
  *{$name} = sub {
    associate("data::$name", $_[1] || join('', <STDIN>)) if @_ > 0 && $_[0] eq '=';
    retrieve("data::$name");
  };
};
__j7lFraXGRfKk8ymj2mDJhNbCQMk9FSciN1hdDhzM99U

meta::meta('datatypes::function', <<'__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0');
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "function::$name";
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__XSIHGGHv0Sh0JBj9KIrP/OzuuB2epyvn9pgtZyWE6t0

meta::meta('datatypes::internal_function', <<'__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong');
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = eval "sub {\n$value\n}";
  carp $@ if $@;
};
__heBxmlI7O84FgR+9+ULeiCTWJ4hqd079Z02rZnl9Ong

meta::meta('datatypes::library', <<'__3RHc2q2OKjeHL1QRq6jhHHCeSrNLDPWTwSax7MclXRE');
meta::define_form 'library', sub {
  eval $_[1];
  warn $@ if $@;
};
__3RHc2q2OKjeHL1QRq6jhHHCeSrNLDPWTwSax7MclXRE

meta::meta('datatypes::list-type', <<'__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w');
meta::define_form '_list_type', sub {
  my ($outer_name, $outer_value) = @_;
  $externalized_functions{$outer_name} = "_list_type::$outer_name";
  
  *{$outer_name} = sub {
    associate("${outer_value}::$_", '') for @_;
  };

  meta::define_form $outer_value, sub {
    my ($name, $value) = @_;
    $externalized_functions{$name} = "${outer_value}::$name";
    *{$name} = sub {
      my ($command, @xs) = @_;
      my $xs = join "\n", @xs;
      return grep length, split /\n/, retrieve("${outer_value}::$name")               if $command eq 'items';
      associate("${outer_value}::$name", retrieve("${outer_value}::$name") . "\n$xs") if $command eq 'add' || $command eq '<<';
      edit("${outer_value}::$name")                                                   if $command eq 'edit';
      return retrieve("${outer_value}::$name");
    };
  };
};
__OKczvJ+6wi8VPNFcZ9ohlXjw+ychodWCfcELdli9p+w

meta::meta('datatypes::note', <<'__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34');
meta::define_form 'note', sub {
  my ($name, undef) = @_;
  $externalized_functions{$name} = "note::$name";
  *{$name} = sub {edit("note::$name")};
};
__TGOjJwmj+QJp1giUQqg2bEaQe8RvqnrFEqyZhIpSC34

meta::meta('datatypes::sh', <<'__+0AR2hHnh+UldymM4MpYnXCE52tHTO+7Lp7HXSsKyTM');
meta::define_form 'sh', sub {
  my ($name, $value) = @_;
  $externalized_functions{$name} = "sh::$name";
  *{$name} = sub {
    my ($name, @args) = @_;
    my $filename      = state_based_filename() . '.tmp';
    my $new_value     = $value;

    @args || push(@args, $name) && ($name = 'unlit');

    file::write($filename, &$name(@args));
    $new_value =~ s/__code__/$filename/go;
    my $output = system($new_value);
    unlink $filename;
    $output;
  };
};
__+0AR2hHnh+UldymM4MpYnXCE52tHTO+7Lp7HXSsKyTM

meta::meta('datatypes::vim-highlighter', <<'__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0');
meta::define_form 'vim_highlighter', \&meta::bootstrap::implementation;
__vsGBLVDC3S+pX/k/zl5CgXeAQz2QjpBkLgx0CJ4vcn0

meta::meta('internal::runtime', <<'__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA');
meta::define_form 'internal', \&meta::meta::implementation;
__Nd6Dp1A6nL7yAGeoRfeZETeaW8vnPN8HI9Diqo66vDA

meta::_list_type('list', <<'__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk');
list
__ozA5XMClOtEgdzZUav/0c1lAk3Vku/dc4e2tQHgNkTk

meta::bootstrap('initialization', <<'__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc');
#!/usr/bin/perl

use File::Temp  'tempfile';
use Carp        'carp';
use Digest::SHA 'sha256_base64';

$|++;

my %data;
my %transient;
my %externalized_functions;
my @data_types;
my @script_args;

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  push @data_types, $namespace;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  eval $value;
  carp $@ if $@;
};

__plktoDCjGQioE48vwfrH0xL3ulcYnTWp+fUvaFwRnnc

meta::bootstrap('pod', <<'__3uM+GRhsAnxE6BFehM2nkGju4J93JQjqONxKbpE0Cdg');

=head1 NAME

object - Stateful file-based object

=head1 SYNOPSYS

object [options] action [arguments...]

object shell

=head1 DESCRIPTION

Stateful objects preserve their state between executions by rewriting themselves. Each time the script exits it replaces its contents with its new state. Thus
state management, for user-writable scripts, is completely transparent.

An object rewrites itself only if its state has changed. This may seem like a dangerous operation, but some checks are put into place to ensure that it goes
smoothly. First, the object is initially written to a separate file. Next, that file is executed and asked to provide a hashsum of its contents. The original
object is rewritten only if that hashsum is correct. This ensures that the replacement object is functional and has the right data.

Currently the only known way to lose your data is to edit the serialization-related functions in such a way that they no longer function. However, this is not
something most people will normally do. In the future there may be a locking mechanism to prevent unintentional edits of these attributes.

=cut

__3uM+GRhsAnxE6BFehM2nkGju4J93JQjqONxKbpE0Cdg

meta::code('main', <<'__hdF67Yz9gjcjqjrHWb2pg6b/g2p8yM7BypLccp9YrJI');
Divergence JavaScript Library | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

Language.
  Divergence parses (almost) all valid JavaScript code and translates operators into method calls. At some later date, it will probably allow you to do CPS-conversion on your code as well.
  There are a couple of things to be aware of:

    | 1. Operator translation makes things slow! If you're doing number crunching, you should not do it in an overloaded context unless you're confident that your JS interpreter inlines
         functions. Numbers, booleans, and strings have their operators routed through prototype methods, so writing a normal array iterator:

         | for (var i = 0, l = xs.length; i < l; ++i)

       | will in fact generate this code:

         | for (var i = 0, l = xs.length; i["<"](l); ++i)

         What was a comparison will now have the overhead of a method call.

    | 2. Divergence supports macro operators. USE THESE SPARINGLY! The >$> operator is a built-in macro that builds a function. This has the result that no object can overload >$>, since it
         will never be present in generated code (unless a macro puts it there, which would be confusing). Much more readable in the general case is the prefix macro form:

         | some_macro(foo, bar, bif)

         This gives your code the ability to see the parse trees for foo, bar, and bif and transform them arbitrarily. There are two advantages to prefix macros. One is that there are many
         more identifier names than operator names, so there's less likely to be a conflict. The other is that the precedence is unambiguous.

  Things Divergence doesn't support:

    | 1. Switch/case. This is because I'm too lazy to implement parsing for it.
    | 2. 'Standard form' function definitions. Functions need to be declared as vars rather than as 'function foo () {...}'.
    | 3. Labels and named break/continue.
    | 4. Prefix - and + operators inside expressions, including negative number literals. These are interpreted as belonging to the preceding operator.

  It will probably support these at some point in the future.

Divergence standard library.
  When you're constructing anonymous functions with the >$> infix operator, you'll run into some limitations of the JavaScript parse tree. One is that code blocks don't fit into an expression
  context, so you're limited to using only valid expressions and operators. This creates a number of limitations:

    | 1. No if, for, while, do, throw, try/catch, switch, return, break, continue, etc. statements
    | 2. No variable definitions with /var/ (though see the <- operator)

  This section describes ways of working around these limitations.

  The /if/ statement is unavailable in expression context. To perform conditional execution, the ||, &&, and ?: operators should be used with the comma operator. Alternatively, you can use the
  Boolean monad to bind against an anonymous function:

    | condition >>- (x >$> 'foo')         // equivalent to condition && 'foo'

  Similarly, the /for/ and /while/ constructs are also unavailable. To perform tail-recursive looping, you should use the Array map operator (also written as *) or bind the array monad to a
  function:

    | [1, 2, 3] * (x >$> x + 1)           // [2, 3, 4]
    | [1, 2, 3] >>- (x >$> [x, x + 1])    // [1, 2, 2, 3, 3, 4]

  Anonymous functions don't have to be constructed with the >$> operator. In practice, you will probably use a more compact notation such as this:

    | [1, 2, 3] * ($_ + 1)
    | [1, 2, 3] >>- [$_, $_ + 1]

  $_ is the identity function (available outside of divergent functions as d.$_), and functions overload operators to compose. Values that aren't functions, such as 1, are callable and return
  themselves. Arrays call each of their parameters as a function when called, so this distributive law holds:

    | [f, g] (5)                    // [f(5), g(5)]
    | [f, g] >>- ($_ (5))

  Note that the invocation operator () is translated into the /call/ method, so any data type can overload it.

Semigroup properties.
  Most types are monoidal, though most are not commutative. A type indicates that it is monoidal by providing a 'zero' attribute directly on the constructor and overloading the + operator,
  like this:

    | String.zero + 'foo'

  Arrays, hashes, functions, strings, booleans, and numbers are all monoids with the zero elements [], {}, $_, '', false, and 0, respectively. Their semantics are straightforward:

    | [x1, x2, ..., xn] + [y1, y2, ..., yn] = [x1, x2, ..., xn, y1, y2, ..., yn]
    | {x1: y1, x2: y2, ...} + {x1: z1, x3: z2, ...} = {x1: z1, x2: y2, x3: z2, ...}
    | (f1 + f2) (x) = f1(x) + f2(x)
    | b1 + b2 = b1 ^ b2
    | n1 + n2 = n1 + n2

  All pure functions are homomorphic under most operations. The only notable exception is the invocation operator, which clearly behaves differently -- e.g. f1(f2)(x) != f1(x)(f2(x)).

Operators.
  Because functions in JavaScript must compile into a valid JavaScript parse tree, there are some limitations placed on the operators that can be overloaded. In particular, one cannot create
  new operators arbitrarily, so defining the binary ++ operator to concatenate arrays, for example, would be invalid. However, by (mis)using the $ character (which parses as an identifier), we
  can create new compound operators that widen our options:

    | x >$> (x + 1)             // the lambda operator (which is a macro; see below)
    | x >$+ 'foo'               // an operator whose behavior has yet to be defined
    | x <<$* [1, 2, 3]          // ditto
    | x +$+ [1, 2, 3]           // maybe this will be an acceptable alternative to ++

  The only rule put into place is that you can't use lvalue-sensitive operators (these include assignment operators, ++, and --). Other than that, you're free to overload as many of these
  operators as you'd like. Their precedence, however, is determined by JavaScript's precedence rules; this is a necessary evil because SpiderMonkey's toString() function removes unnecessary
  parentheses. If the >$> operator were assumed to have precedence equivalent to =, for example, then you would be unable to define the expression (x >$> x) < 5 because the () around >$> would
  be erased. So unfortunately it has relational-operator precedence, making it necessary to say x >$> (x < 5) rather than the more convenient x >$> x < 5.

  Operators always map to method calls. The method calls are simply the characters of the operator, so for instance the expression 'x >>- (y + z)' is translated into 'x[">>-"](y["+"](z))'.

  Divergence takes liberties to parse certain expressions as long-form operators; in particular, unary negation will be interpreted as being part of the preceding operator rather than a
  negation. This works out OK for numbers, since the operators '+-', '*-', etc. are defined to do the right thing. But it does mean that when you're defining your own numerical operators
  you'll need to watch out for this.

Restrictions on operator overloading.
  You cannot overload operators that require the left-hand-side to be an lvalue. These will be translated into their full form for consistency (e.g. x += 1 to x = x + 1) in a precedence-aware
  way before expanding the operators into method calls. By implication, then, the [] operator is off-limits since there would then be no way to assign to indirected slots.

Macros.
  Sometimes you want to write an operator or function that has the ability to rewrite code. Fortunately, this is quite a straightforward process. The >$> macro is one such construct, and it is
  defined like this:

    | d.infix ('>$>', function (x, y) {return '(function(' + x + '){return ' + y + '})'});

  Prefix macros can also be defined. They resemble normal function calls and look like this:

    | d.prefix ('foo', function (x, y, z) {return x + ' + ' + y + ' * ' + z});

  That macro would transform any occurrences of the expression foo(3 + 5, x, y + 1) into the code (3 + 5) + x * (y + 1).

  There are a couple of reasons I decided to go with this somewhat weak macro model. The first is that this code is likely to be compiled each time the JavaScript is loaded (though you can
  always call toString() on the resulting function to grab its source and save it for later), and the second is that an overuse of macros can be detrimental to code maintainability.

  Also, think carefully before making an operator into a macro. Once you do this, objects won't be able to overload that operator anymore. Functions have workarounds, but operators don't.

var d = (function (cache) {
  var        qw = function  (s) {return s.split (' ')},
            set = function (xs) {return init ({}, function () {for (var i = 0, l = xs.length; i < l; ++i) this[xs[i]] = true})},
           init = function  (o) {for (var i = 1, l = arguments.length, $_; $_ = arguments[i], i < l; ++i) if ($_.constructor === Function) $_.call (o);
                                                                                                          else                             for (var k in $_) o[k] = $_[k]; return o},
      prototype = function (f, p) {return init (f, function () {init (this.prototype, p)})},
           last = function   (xs) {return xs[xs.length - 1]},
             ll = function   (xs) {return last(last(xs))},

     precedence = {'function':0, '[]':1, '.':1, '()':1, 'unew':2, 'u++':3, 'u--':3, 'utypeof':3, 'u~':3, 'u!':3, 'u+':3, 'u-':3, '*':4, '/':4, '%':4, '+':5, '-':5, '<<':6, '>>':6, '>>>':6,
                   '<':7, '>':7, '<=':7, '>=':7, 'instanceof':7, 'in':7, '==':8, '!=':8, '===':8, '!==':8, '&':9, '^':10, '|':11, '&&':12, '||':13, '?':14, ':':14, '=':15, '+=':15, '-=':15,
                   '*=':15, '/=':15, '%=':15, '&=':15, '|=':15, '^=':15, '<<=':15, '>>=':15, '>>>=':15, ',':16, '{}':17, ';':18, 'if':19, 'for':19, 'while':19, 'do':19, 'try':19, 'catch':19,
                   'finally':19, 'function':19, 'var':19, 'else':19},
     predicated = set(qw('if while catch')),
 non_predicated = set(qw('do try finally var const else')),
    expressions = set(qw('throw return break continue')),
          right = set(qw('? : = += -= *= /= %= &= ^= |= <<= >>= >>>= u~ u! unew utypeof u+ u- u++ u--')),
        unaries = set(qw('++ -- u++ u-- u+ u- u! u~ new typeof <array> <object> var')),
       literals = set(qw('= += -= *= /= %= ^= |= &= <<= >>= >>>= , && || === !== u! unew [] instanceof in typeof :')),
        openers = set(qw('if while catch do try finally var const else for ? ( [ { function')),
         idents = set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_'.split ('')),
        closers = {'e':';}])', '?':':', '{':'}', 's':'};', 'S':'}'},
      ternaries = {'?': ':'},
         macros = {'<object>': function (x) {return '{' + x + '}'}, '<array>': function (x) {return '[' + x + ']'}},
           pair = {'(':')', ')':'(', '[':']', ']':'[', '{':'}', '}':'{'},

              s =  function (s) {return s === undefined || s === null ? '' : s.toString ()},
           norm =  function (o) {return ({'(':'()', '[':'[]', ')':'()', ']':'[]'})[o] || o},
             op =  function (o) {return '+-*/%&|^!~=<>?:;.,'.indexOf (o) > -1},
           prec = (function (c) {return function (o) {
                    if (c[o]) return c[o];
                    var p = 20, os = o.split ('$'); for (var i = 0, l = os.length, $_; i < l; ++i) ($_ = precedence[os[i]]) && $_ < p && (p = $_); return c[o] = p}}) ({}),

          unary = prototype (function (op, rhs) {this.op = op, this.rhs = rhs}, {toString: function () {return macros[this.op] ? macros[this.op] (this.rhs) : (this.op + ' ' + s(this.rhs))}}),
         binary = prototype (function (op, rhs, lhs) {this.op = op, this.lhs = lhs, this.rhs = rhs}, {
                             toString: function () {return ',.:'.indexOf (this.op) > -1 ? s(this.lhs) + (this.lhs ? this.op : '') + s(this.rhs) :
                                                                       this.op === '[]' ? s(this.lhs) + '[' + s(this.rhs) + ']' :
                                                                        macros[this.op] ? macros[this.op] (this.lhs, this.rhs) :
                                                                      literals[this.op] ? '((' + s(this.lhs) + ')'        + this.op +   '(' + s(this.rhs) + '))' :
                                                                                           '(' + s(this.lhs) + ')' + '["' + this.op + '"](' + s(this.rhs) + ')'}}),

        ternary = prototype (function (op, _3, _2, _1) {this.op = op, this._1 = _1, this._2 = _2, this._3 = _3}, {
                             toString: function () {return '((' + s(this._1) + ')' + this.op + '(' + s(this._2) + ')' + ternaries[this.op] + '(' + s(this._3) + '))'}}),

          block = prototype (function (stuff) {this.stuff = stuff || []}, {toString: function () {return this.stuff.join (';\n')}}),

JavaScript parsing.
  I'm using an inlined recursive-descent parser with flattened states and a streaming lexer to parse the source code. This is basically the same thing as a regular recursive-descent parser
  that delegates to a shunting yard algorithm for arithmetic parsing, except that it takes a bunch of shortcuts derived from the knowledge that the input is already well-formed. Well-formed
  input means that we can actually parse a much more general language than JavaScript, and this results in a more compact parser.

  Here is the optimized grammar (separate production lines are alternatives):

    |      statement ::= <predicated> (<expression>) <statement>
                         for (<statements>) <statement>
                         <non_predicated> <statement>
                         <block>
                         <expression> ;
                         ;

    |          block ::= { <statements> }

    |     statements ::= <statement>
                         <statement> <statements>

    |     expression ::= ( <expression> )
                         [ <expression> ]
                         { <expression> : <expression> , ... }
                         function (<expression>) <statement>
                         <expression> <binary_op> <expression>
                         <expression> ? <expression> : <expression>
                         <unary_op> <expression>
                         <expression> <unary_op>
                         <literal>
                         <ident>

    |     predicated ::= if | while | catch
    | non_predicated ::= do | try | finally | var | const | else

    |             op ::= ...

  There are a few deviations that I'm making for the purposes of simplicity. I'm storing the derivation path, since that impacts how certain operators are interpreted. In particular, consider
  the expression {foo: 'bar'}. Interpreted in statement context it is a block with a labeled expression, and interpreted in expression context it's an object literal.

Lexing.
  The lexer is for the most part straightforward. The only tricky bit is regular expression parsing, which requires the lexer to contextualize operators and operands. I've implemented this
  logic with a last_was_op flag that indicates whether the last token processed was an operator (if so, then we're expecting an operand and the next / delineates a regular expression). The
  lexer also determines whether a set of parentheses or square brackets are being used in an invocation or slice; if they are, then it produces the tokens () or [], respectively, rather than
  just the ( or [ that was read.

Parsing.
  There are a few different parse modes we can be in. One of them is the 'expecting a statement' mode, where we look for /for/, predicated things, non-predicated things, and block openers.
  When we find one of these operators, we push our state (the output queue and pending queue), and push the trigger element onto the path. (This lets us preserve context for the next
  'operand', if there is one.)

  Another mode is the 'expecting an expression' mode, which exits if we hit a ;. It also exits if we hit a , and the last element on the path is an object literal opener. So the difference
  between 'pending' and 'path' is that 'pending' represents unprocessed operators for this processing mode, and 'path' indicates the mode that we're in. 'output' maintains a queue of elements
  for the current state. When we transition out of the current state, pending operations are performed and then the output queue (a doubly-indirected structure just like 'pending') is passed
  to the delegate for the state we're in. (This makes it simpler to process argument lists, object literals, and so forth.)

  The third mode is 'waiting for the : to a ?' mode, which munches everything until the next ':'. Technically this isn't quite correct, but the incorrect cases will be filtered out by the
  initial JavaScript parse. It ends up treating the ? as a type of opening paren, and thus expects a : to close it.

  Here are some cases.

    Case 1. We're in statement mode and encounter the word 'var'. Then we push our state, put 'var' onto the pending stack (as a prefix unary operator), put 'e' on the path, and continue. Once
            we hit the closer ';', we reduce all pending operations, apply 'var' to the remaining output, and push that single output element onto the list of outputs from the previous run.
            Then we pop the 'e' off of the path and pop the empty output and pending arrays.

    Case 2. We're in statement mode and encounter the word 'if'. We'll need to parse two different things, first an expression and then a single statement. This isn't too difficult; we just
            need to push both states in the right order. We push the current state, put the 'if' onto the pending queue, put an 's' on the path, push the state again, and put an 'e' on the
            path. We also absorb the next token, an open-paren, and go to parse the expression. It will exit on the close-paren and pop its state onto the end of the parent state's output
            queue, then will parse a single statement. When that statement finishes parsing the pending queue will be run, and this will finish with the 'if' that was pushed in the beginning.
            The state is popped and the single statement on the output queue is pushed onto the parent state's output.

    Case 3. We're in statement mode and encouter the word 'function'. Since we don't parse the statement-form of 'function', we know this should be interpreted as an expression. We push our
            state, push an 'e' onto the path, push the word 'function' onto the pending queue, push our state again, push an 's' onto the path, push our state once more, push an 'e' onto the
            path, and absorb an open paren. (The logic is similar to 'if', except with the extra transition into expression-mode.) The word 'function' has top precedence, so the next operator
            will cause it to bind to the two topmost output items, the argument list and the body.

    Case 4. We're in expression mode and encounter the symbol ';'. This is in the closers for the path 'e', so we process all operations on the pending queue and pop our state, pushing the
            output element onto the parent's output queue.

    Case 5. We're in single-statement mode and encounter the symbol '{'. We push our state and push 'S' onto the path (indicating that we don't quit when we hit a ';'). Then we parse until we
            hit the closer '}'. This isn't the end, unfortunately. When we pop and push onto the parent's output, we wrap the separate statements in a block constructor and check the parent
            state. If the state is 's', then we pop out of that one too; otherwise we just leave it. This handles the single-statement case present on if-blocks (they aren't terminated by a
            semicolon, but the 'if' just takes one block).

    Case 6. We're in expression mode and encounter the symbol '{'. We push our state and push '{' onto the path. This is a special form of expression mode where ':' and ',' act as
            left-associative infix binary operators whose precedences are the two lowest. When the '}' is encountered, we process all pending operations, wrap the result in an object
            constructor, and pop the state, pushing the single constructed object onto the parent output queue.

  All of this means that the logic for closers such as }, ], and ) is this. Any one of those will run the pending queue until we hit the corresponding opener. If we never do (leaving the
  pending queue empty), then we pop the state and delegate to the state transition handler specified by the above cases. Note that as yet we haven't pushed the opener, so we do this after the
  state has been popped. What this means is that absorbing the open-paren or what-not actually means that we push it onto the parent pending queue so that it will match up with the closer that
  gets us out of the child queue.

  In other words, to set up a balanced paren read, we take the open-paren in the current state and then push the state, leaving a paren balance of 1. The final close paren will exit the new
  state and match the one we have, which should do exactly what we want since we have only one element.

  The parser starts off in multi-statement mode (S).

          parse = function (s) {var i = 0, $_, l = s.length, token = '', last_was_op = true, output = [[]], pending = [[]], path = ['S'], absorb = 0, c = function (i) {return s.charAt (i)},
                                    a = function (t) {last(output).push (unaries[t] ? new   unary (t, last(output).pop ()) :
                                                                          t === '?' ? new ternary (t, ($_ = last(output).pop ()).rhs, $_.lhs, last(output).pop ()) :
                                                                                      new  binary (norm(t), last(output).pop (), last(output).pop ()))},
                        do_precedence = function (t) {while (($_ = ll(pending)) && (right[$_] ? prec($_) < prec(t) : prec($_) <= prec(t))) a(last(pending).pop ())},
                           do_pending = function  () {while (last(pending).length) a(last(pending).pop ())},
                           push_state = function (s) {output.push ([]), pending.push ([token]), s ? (path.push (s)) : path.push ('e')},
                            pop_state = function  () {do_pending (); var p = path.pop (); (delegates[p] || delegates.path (p)) (output.pop ()); pending.pop ()},
                push_expression_token = function (t) {t === 'function' ? push_state ('e') : last_was_op || t === '(' ? (do_precedence (t), last(pending).push (t)) : last(output).push (t)},
                            delegates = {'s': function (xs) {output[output.length - 1] = last(output).concat (xs)}, 'S': function (xs) {output[output.length - 1] = last(output).concat (xs)},
                                         'e': function (xs) {output[output.length - 1] = last(output).concat (xs)}, '?': function (xs) {output[output.length - 1] = last(output).concat (xs)},
                                        path: function  (p) {return function (xs) {last(output).push (new unary (p, xs))}},
                                         '{': function (xs) {last(output).push (new block (xs))}};

                while (i < l && ($_ = c(i))) {
                       if                                  (/\s/.test ($_))                                                       ++i;
                  else if       (! last_was_op && '?:(['.indexOf ($_) > -1)                                                       last_was_op = !! (token = norm($_)), ++i;
                  else if                      ('([{}])'.indexOf ($_) > -1)                                                       last_was_op =  ! (token = $_), ++i;
                  else if                  ($_ === '/' && c(i + 1) === '*') while  (c(++i) !== '/' || c(i - 1) !== '*' || ! ++i);
                  else if                  ($_ === '/' && c(i + 1) === '/') while             (c(++i) !== '\n' && c(i) !== '\r');
                  else if ($_ === '/' &&    last_was_op &&  (token = '/'))  while (c(++i) !== '/' || c(i - 1) === '\\' || ! ++i)  last_was_op =  ! (token += c(i));
                  else if ($_ === '"' && ! (last_was_op = ! (token = '"'))) while (c(++i) !== '"' || c(i - 1) === '\\' || ! ++i)  token += c(i);
                  else if ($_ === "'" && ! (last_was_op = ! (token = "'"))) while (c(++i) !== "'" || c(i - 1) === '\\' || ! ++i)  token += c(i);
                  else if          (last_was_op && op($_) && (token = 'u')) while      (op($_ = c(i)) && precedence[token + $_])  last_was_op = !! (token += $_), ++i;
                  else if                                          (op($_)) while      (op($_ = c(i)) && precedence[token + $_])  last_was_op = !! (token += $_), ++i;
                  else                                                      while                            (idents[$_ = c(i)])  last_was_op = !! precedence[token += $_], ++i;

                  if (token && ! absorb) if ('sS'.indexOf ($_ = last(path)) > -1 && ';}])'.indexOf (token) > -1) token === ';' && $_ === 'S' ? do_pending () : pop_state (); 
                                         else if (openers[$_])                                                   push_state (predicated[token] ? 'e' : non_predicated[token] ? 's' : token === 'for' ? 'S' :
                                                                                                                             token === '{' ? 'S' : token === '?' ? '?' : '');
                                         else                                                                    closers[$_].indexOf (token) > -1 ? token === ',' ? do_pending () : pop_state () :
                                                                                                                                                    push_expression_token (token);
                  absorb && --absorb;
                  token = '';
                                }
                                while (path.length > 1) pop_state ();
                                do_pending ();
                                return output.pop ().toSource ()};

  return parse;
}) ({});
__hdF67Yz9gjcjqjrHWb2pg6b/g2p8yM7BypLccp9YrJI

meta::code('scratch', <<'__UFvA92B98GVzh3boXGxl19QiD9162rJI14MuI2vyVq0');
This is for scratchwork that isn't part of your system. It could be used for testing or other experimentation.
:: get main
__UFvA92B98GVzh3boXGxl19QiD9162rJI14MuI2vyVq0

meta::code('test', <<'__V3BbWD240PqWRbe2Fmzd6CiSU06VIpHc7O7jtQx+WEM');
Divergence unit tests | Spencer Tipping <spencer@spencertipping.com>
Licensed under the terms of the MIT source code license

:: get main

  var assert       = function (x, msg) {if (! x) throw new Error ("Assertion failed: " + msg)};
  var assert_equal = function (x, y, msg) {x === y || assert (x === y, msg + ' -- ' + x.toString () + ' !== ' + y.toString ())};

  var trace        = function (x) {print (x); return x};

  var test         = function (s) {print (d (s))};

  test ('foo.bar.bif.baz');
  test ('foo . bar . bif . baz');
  test ('foo + bar * bif');
  test ('foo * bar + bif');

  test ('foo ? bar : bif');
  test ('foo ? bar ? bif : baz : bok');

  test ('var x = 5');
  test ('var x = 5, y = 6');
  test ('{foo; bar; bif; baz}');
  test ('if (foo) {bar; bif}');

  test ('foo + (bar == bif) * (baz === bok)');

  test ('foo () () () ()');

  test ('typeof new new new new foo ()');

  test ('foo instanceof bar');
  test ('foo in bar');

  test ('foo >$* x + bar >>$>> baz');
  test ('foo >>- bar');
  test ('foo > $ * bar >> -baz');

  test ('foo + bar(bif)');
  test ('foo() + bar()');

  test ('foo = bar = baz');

  test ('foo(bif)');
  test ('foo // bif\n(bar)');
  test ('foo /* bar */ (bif)');
  test ('foo("bar + bif")');
  test ('foo("bar\\" + bif\\"")');
  test ('foo(/bar + bif/)');
  test ('foo(\'bar + bif\')');
  test ('{foo: "bar", bif: "baz"}');
  test ('{foo: "bar" ? "bif" : "baz", bar: "bif" || "baz"}');
  test ('[foo, bar, bif, baz]');
__V3BbWD240PqWRbe2Fmzd6CiSU06VIpHc7O7jtQx+WEM

meta::data('default-action', <<'__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc');
shell
__zmNcTqv/Xk9W26j7HjnKI1UwqitrGFM+7xrzhiAWxXc

meta::data('meta-associations', <<'__PRn3E4sEYBafwIXKC61VRabCemMeSeRn2H7z3wLgOo4');
^function:: .pl
^internal_function:: .pl
^meta:: .pl
^bootstrap:: .pl
^code:: .ljs
^vim_highlighter:: .vim
__PRn3E4sEYBafwIXKC61VRabCemMeSeRn2H7z3wLgOo4

meta::data('name', <<'__mr88igdDVcDPwZrY2e6T57JGQ5ZIqA5D3C5BubQZQn8');
divergence
__mr88igdDVcDPwZrY2e6T57JGQ5ZIqA5D3C5BubQZQn8

meta::function('add-to', <<'__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q');
my ($filename) = @_;
my @members = grep /^implementation::/, keys %data;

for (@members) {
  my $destination_name = basename($_);
  open my($handle), "| $filename import $destination_name" or messages::error("Attribute $_ could not be written.");
  print $handle retrieve($_);
  close $handle;
}
__KBgra0vG1gIsUI8CCVf4ZEdCatZDCdVO6HuUx+jOJ9Q

meta::function('attributes', <<'__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg');
grep /^attribute::/, sort keys %data;
__SHSGXpl5WufcHc7hGxs0XPxlKSgo0XQ752HpjI4rgRg

meta::function('cat', <<'__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk');
my ($name) = @_;
$data{$name};
__h2PeSpk/pPmrzLRTTofdLTbhj06IWUw5WWke6ggUsdk

meta::function('clone', <<'__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__qP6xPZE75s9g0XJIiC6FGw0vnj2j0glUzsAHxyA3lvY

meta::function('code', <<'__NBNecoJ9JVwyGbA+8LrNYjQKQyQOxdFAkjgZ4ueT5QA');
join "\n\n", map preprocess(retrieve("code::$_")), @_;
__NBNecoJ9JVwyGbA+8LrNYjQKQyQOxdFAkjgZ4ueT5QA

meta::function('cp', <<'__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4');
my ($from, $to) = @_;
$data{$to} = $data{$from} if $data{$from};
messages::error("No such attribute $from") unless $data{$from};
$data{$from};
__yn1SQkcEk6o+gnuCy3QGVFtQb2piaCoUdJPGUkLjpD4

meta::function('create', <<'__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc');
my ($name, $value) = @_;
messages::error("Attribute $name already exists.") if grep {$_ eq $name} keys %data;
if ($value) {
  associate($name, $value);
} else {
  associate($name,'');
  edit ($name);
}
__YDNTuzkJSNUIk4tbdwxep6/rT8uGnceIj7rljM9gusc

meta::function('edit', <<'__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE');
my ($name, %options) = @_;

my $meta_extension = join '', grep {
  my $s = $_;
  $s =~ s/\s.*$//;
  $name =~ /$s/
} split /\n/, &{'meta-associations'}();

$meta_extension =~ s/^.*\s//;
chomp $meta_extension;

messages::error("Attribute $name does not exist.") unless grep {$_ eq $name} keys %data;
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, extension => $meta_extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
delete $data{$name} if length($data{$name}) == 0;

save();
__rAkSOSll0evjt/D0qmnz2M++ACqz6cPtN8TLTHdQUJE

meta::function('exists', <<'__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk');
my $name = shift;
grep {$_ eq $name} keys %data;
__bxU1sDtIh3+P1x0HuuY0f7sKHr9qNZUEl64m2fvwmDk

meta::function('export', <<'__I4eRG7HtLDZhFgrlr0QDrQO5MRwJYGFlotQsWQIE/d8');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map {cat($_)} @attributes;
  file::write ($name, $file);
} else {
  messages::error ("Not enough arguments");
}
__I4eRG7HtLDZhFgrlr0QDrQO5MRwJYGFlotQsWQIE/d8

meta::function('grab', <<'__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8');
my ($filename, @attribute_names) = @_;
associate("implementation::$_", `$filename cat $_`) for @attribute_names;
__sXs1aeJVBERH6nWE7ZpWiIO5Cg7fSBWcoscDg1DHzD8

meta::function('import', <<'__7f1Q36AcIJ8/OaaYPGUq10PPFTKnEF0CMxS56DRsjKk');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__7f1Q36AcIJ8/OaaYPGUq10PPFTKnEF0CMxS56DRsjKk

meta::function('listing', <<'__ISxcI25BrOnRRxDUQm5UL5wWzHJxL/OY8QdSUdnRJoE');
my ($profile, $line, $context) = @_;
$line    ||= 1;
$context ||= 4;

my $result = '';
my @lines  = split /\n/, unlit($profile);
for my $l ($line - $context .. $line + $context) {
  next if $l <= 0;
  last if $l >  @lines;
  $result .= sprintf "\033[1;34m%6d\033[0;0m: %s%s%s\n", $l, $l == $line ? "\033[1;32m" : '', $lines[$l - 1], $l == $line ? "\033[0;0m" : '';
}

$result;
__ISxcI25BrOnRRxDUQm5UL5wWzHJxL/OY8QdSUdnRJoE

meta::function('load-dependencies', <<'__oYAWdUSIg7K9xPssNpQhu7nUGr94qBGg5QJpTDAA3sA');
my $errors = '';
for (grep length, split /\n/, &{'dependencies'}()) {
  terminal::message('loader', "Running integration test checks on $_...");
  my $output = `$_ :check`;
  chomp $output;
  $errors .= $output ? "module $_\n$output\n" : '';
}

return terminal::message('error', "dependency loading failed:\n$errors") if $errors;
associate('code::cached-dependencies', join('', map `$_ :export`, grep length, split /\n/, &{'dependencies'}()));
terminal::message('loader', "imported dependencies");
__oYAWdUSIg7K9xPssNpQhu7nUGr94qBGg5QJpTDAA3sA

meta::function('lock', <<'__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__pqf/HijyN91BWpnS+uWYip/mFhHhcd+M9/YdlYsvv9Y

meta::function('ls', <<'__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg');
join("\n", sort keys %externalized_functions);
__M3wGXSw8/xm3RiNq0uLWke1dHm2OWQbvJpHkngdPafg

meta::function('ls-a', <<'__3Ou+kVmaLIe1oZKBOufKY7pSsksgTSAfNeXRniPFZPk');
join("\n", sort keys %data);
__3Ou+kVmaLIe1oZKBOufKY7pSsksgTSAfNeXRniPFZPk

meta::function('mv', <<'__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4');
my ($from, $to) = @_;
messages::error("The '$from' attribute does not exist.") unless grep $from, keys %data;
associate($to, retrieve($from));
rm($from);
__ijyNZ8r34FVK0Ki9/Q0Irx5k9U0pZ+/frrdlu+qkEP4

meta::function('perl', <<'__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA');
my $result = eval($_[0]);
$@ ? $@ : $result;
__Ojd593Fa9fx1Yx2XuPzK6WTUyxO70Nbmlbl9YRodUWA

meta::function('pop-state', <<'__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__eqnCLsMapvq2sYSx82KCxh25zmff+JIXFMYUan2kGKM

meta::function('preprocess', <<'__SP+M4pf8VRk5hJv0AVOHi8DdG8vAj6ClENKjab8Vbg8');
my ($document) = @_;
my %commands = (get => sub {"\n" . code(split /\s+/, $_[0]) . "\n"});
join "\n", map {m/^\s*::\s*(\w+)\s(.*)$/o && defined $commands{$1} ? $commands{$1}($2, $_) : $_} split /\n/, $document;
__SP+M4pf8VRk5hJv0AVOHi8DdG8vAj6ClENKjab8Vbg8

meta::function('pull', <<'__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg');
my ($class_name) = @_;
my @attributes = grep /^implementation::/, split /\n/, `$class_name ls-a`;

for (@attributes) {
  s/^\s+//;
  s/\s+$//;
  print STDERR "Adding $_\n";
  associate(basename($_), `$class_name cat "$_"`);
}
__ZU6uOu7dBdjjoNdEL/U7yrjicOQR5OLFQAacjrKqSCg

meta::function('push-state', <<'__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__ik0ofu7R8gHAKSmMjek79V+yfgdjdK5Jmtwf7h8SpJk

meta::function('reload', <<'__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM');
execute($_) for (grep {! (/^internal::/ || /^bootstrap::/)} keys %data);
__GwQjnnfuj0xQlervDJ9EVWzdmdz+XL3Gq0i9rdejvzM

meta::function('repl', <<'__w4q9MpioWHnb4gpiwN2R0N69hoQm0kvxzUBS6knEULg');
my ($name, @options) = @_;

use Term::ReadLine;

my $term = new Term::ReadLine "$0 repl for $name";
$term->ornaments(0);
my $OUT    = $term->OUT || \*STDOUT;
my $prompt = &{'name'}() . "/$name> ";

terminal::message('repl', 'initializing symbol table');
types::clear_symbols();
types::load_symbols($name) if $name;
types::initialize_symbols();
types::initialize_debugging_symbols() if grep /^debug$/, @options;

terminal::message('repl', 'running session');
run('cached-dependencies') unless grep /^nodeps$/, @options;
run($name) if $name;

terminal::message('repl', 'ready');
while (defined ($_ = $term->readline($prompt))) {
  my $result = eval {reader::read_form($_)->eval()->serialize()};
  $@ ? chomp $@ && terminal::message('error', $@) : terminal::message('result', $result);
}

print "\n";
if ($name) {
  terminal::message('repl', 'storing symbol table');
  types::store_symbols($name);
}

terminal::message('repl', 'exiting');
__w4q9MpioWHnb4gpiwN2R0N69hoQm0kvxzUBS6knEULg

meta::function('rm', <<'__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww');
for my $to_be_deleted (@_) {
  messages::warning("$to_be_deleted does not exist") unless grep {$_ eq $to_be_deleted} keys %data;
}

delete @data{@_};
__7BVECTVo/mcT5+edC70WPc6S1xCbzAeyUCfCjkKWlww

meta::function('run', <<'__2RluS4s8uRjHD6Vtfi/a01P+Bo8jgpcLILqPCD4icpU');
shell::load_interactively(@_);
__2RluS4s8uRjHD6Vtfi/a01P+Bo8jgpcLILqPCD4icpU

meta::function('run-file', <<'__WceprRaNezbwObGfB9h6pwi0Ly281gdWz8CLtXL1ehY');
shell::initialize_symbol_table();
&{':main'}();
shell::load_from_file(@_);
__WceprRaNezbwObGfB9h6pwi0Ly281gdWz8CLtXL1ehY

meta::function('save', <<'__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw');
my $serialized_data = serialize();
my $final_state     = state();

my (undef, $temporary_filename) = tempfile("$0." . 'X' x 32, OPEN => 0);
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

my $observed_state = `perl $temporary_filename state`;
chomp $observed_state;
if ($observed_state ne $final_state) {
  messages::error("The state of this object ($final_state) is inconsistent with the state of $temporary_filename ($observed_state).\n" .
                  "$0 has not been updated.");
} else {
  eval {file::write($0, $serialized_data)};
  warn $@ if $@;
  my $observed_self_state = `perl $0 state`;
  chomp $observed_self_state;
  unlink $temporary_filename if $observed_self_state eq $final_state;
}
__uWXGnrQr+A7Cl0zcsDuiokbWAw1XdMdjeq9gDcTMJIw

meta::function('serialize', <<'__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw');
my @keys_without_internals = grep(!/^internal::/, sort keys %data);
join "\n", $data{'bootstrap::initialization'},
           (grep {$_} (map {serialize::single(@_)} grep(/^meta::/,  @keys_without_internals),
                                                   grep(!/^meta::/, @keys_without_internals),
                                                   grep(/^internal::/, sort keys %data))),
           "__END__";
__KGiI48MlyG6RAVW5QYRK8y97y8tx+jeAwPlY5eDtMTw

meta::function('shell', <<'__mzNaDzdnJhpI/Va1/nY8LTN9BQtfr77CFKIeK2GdIC0');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = &{'name'}() . '$ ';
my $OUT = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      my $result = eval {&{$function_name}(@args)};
      messages::warning($@) if $@;
      chomp $result;
      print $OUT $result, "\n" unless $@;
    } else {
      messages::warning("Command not found: $function_name");
    }
  }

  for my $watch (@{$transient{'watch_list'}}) {
    print $OUT eval($watch), "\n";
    print $OUT "Error evaluating watched expression $watch: $@\n" if $@;
  }

  $prompt = &{'name'}() . '$ ';
}
__mzNaDzdnJhpI/Va1/nY8LTN9BQtfr77CFKIeK2GdIC0

meta::function('size', <<'__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80');
length(serialize());
__lDGr6yVnDwcDWLkJH16MNukltjG2ypBSk/ktYb80h80

meta::function('snapshot', <<'__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;
__qjqsCy4CTt88dIi7IWM+Varpb3GcHsYrFTxW7EwpLW0

meta::function('state', <<'__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI');
sha256_base64 serialize();
__1S8nzRSMoxJU/VEv2rx/NrAt1iRgXQ9ugxjUP3IFunI

meta::function('unlit', <<'__mHW0V1RkAGfY6knX3jpBVyo6OVIjN55Z5o1rIDrqxFU');
join "\n//\n", map {m/^\s*[^0-9a-z_()\[\]{}!\/ ]/o ? s/^/\/\/ /omg : s/^(\s*)!/\1 /o; $_} split /\n\n+/, code(@_);
__mHW0V1RkAGfY6knX3jpBVyo6OVIjN55Z5o1rIDrqxFU

meta::function('unlock', <<'__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__08PohCY8fcNe+pWCO6ic6XOOKv48NkrxpNMmTOUIFdA

meta::function('update-from', <<'__8cUncWUFuzX5fV+tgmVU+RvuWGPysHg3WqI6pYTcrQI');
# Upgrade all attributes that aren't customized. In this case, we want everything except for configuration::, code::, and attribute::.
return "That is a really bad idea." if $0 =~ /\.\/(.*)/ && $_[0] eq $1 || $_[0] eq $0;

terminal::message('info', 'Replicating state...');
&{'push-state'}();
terminal::message('info', 'Updating meta attributes...');
for my $attribute (grep length && /^meta::/, split(/\n/, `$_[0] ls-a`)) {
  associate($attribute, join('', `$_[0] cat $attribute`));
  reload();
  print '.';
}

print "\n";
terminal::message('info', 'Updating non-meta attributes...');
for my $attribute (grep length && ! (/^configuration::/ || /^code::/ || /^attribute::/ || /^function::pop-state$/ ||
                                     /^list::/ || /^issue::/ || /^data::/ || /^meta::datatypes/), split(/\n/, `$_[0] ls-a`)) {
  associate($attribute, join('', `$_[0] cat $attribute`));
  reload();     # Necessary to activate new datatypes.
  print '.';
}

print "\n";
terminal::message('info', 'Reloading new configuration');
reload();
terminal::message('info', "Imported from $_[0]. Run pop-state to undo this change.");
__8cUncWUFuzX5fV+tgmVU+RvuWGPysHg3WqI6pYTcrQI

meta::function('usage', <<'__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I');
<<"EOD" . join '  ', split /\n/, ls ();
Usage: $0 [options] action [arguments]
Defined actions:
EOD
__oHVev4RtZlF/82SSE87y4Bf7ran2afn/HDtukOQBf9I

meta::function('vim', <<'__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for map {s/^vim_highlighter:://o; $_} grep /^vim_highlighter::/, sort keys %data;
__1EcCMR8Tks8HBoOg+zAKJ4LlrRIY8nvLs4M1VTr2Zec

meta::internal_function('associate', <<'__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
messages::error("Namespace $namespace does not exist") unless grep {$_ eq $namespace} @data_types;
$data{$name} = $value;
execute($name) if $options{'execute'};
__D8BKmEFp/adiPPqPnXyMOzlsBMCmuZi62UpJWdoFg/0

meta::internal_function('basename', <<'__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__T4JEqOUYjMzssdVwV/rdgAhvr0Vz9TQUo0noTdeBLxw

meta::internal_function('complete', <<'__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__lhlD80z2kvEUEeHPqLFw6JE8xUdXr6J5Q1gXHg4beHg

meta::internal_function('execute', <<'__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__Ge94WTpmLuqsMDappj5G/G2BKILAE0GjeCqAeHLW6fQ

meta::internal_function('file::read', <<'__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__ZxBqZsMZZRuLMQp8Sy//ZsoAvriDebjYLGAX7p7AxXg

meta::internal_function('file::write', <<'__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o');
my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{'noclobber'} && -f $name;
open my($handle), ">", $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__+NhpMabvNL+hHZaTZwBoFx2IFa79cjOZwGxEXX+xG0o

meta::internal_function('invoke_editor_on', <<'__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U');
my ($data, %options) = @_;
my $content_hash     = sha256_base64($data);
my $editor           = $options{'editor'} || $ENV{'VISUAL'} || $ENV{'EDITOR'} ||
                       messages::error('Either the $VISUAL or $EDITOR environment variable should be set to a valid editor.');
my $options          = $options{'options'} || $ENV{'VISUAL_OPTS'} || $ENV{'EDITOR_OPTS'} || '';
my $extension        = $options{'extension'} || '';

my (undef, $filename) = tempfile("$0." . ("X" x 32), OPEN => 0);
$filename .= $extension;

file::write($filename, $data);
system("$editor $options \"$filename\"");

my $result = file::read($filename);
unlink $filename;
$result;
__97Lgs5+qfyAu92Vv5GCVVSYgUgFhOKYkVYXlbWoUs6U

meta::internal_function('messages::error', <<'__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4');
my ($message) = @_;
die "$message\n";
__200qXouilOAQNa4NkmIj6l+Rvb49Jpy8yxvIX29NcK4

meta::internal_function('messages::warning', <<'__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc');
my ($message) = @_;
print "$message\n";
__DeU/1Klulk/y4fO+wtKt+liOmUKwCEYKM8BvtlXYXBc

meta::internal_function('namespace', <<'__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__D7UfKyyYZ1slZZyaS28hIt8a68jkI3ELBaddROXOHug

meta::internal_function('retrieve', <<'__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM');
@data{@_};
__Erqqkp11FEHKsitr0DEJZ6OCGDYAs+U6BSu4UvLvsFM

meta::internal_function('serialize::single', <<'__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE');
my $name               = shift || $_;
my $contents           = $data{$name};
my $delimiter          = "__" . sha256_base64 $contents;
my $meta_function_name = "meta::" . namespace($name);
my $invocation_name    = basename $name;
"$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__lDBHaXpbrfER2envI2Ipy77IcdjUnlZou+rggaxsAWE

meta::internal_function('state_based_filename', <<'__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__zNSrihAkMKJG5spRYgcFdoNArFKig1u12gIp6gJ8pZw

meta::library('terminal', <<'__bakqo5o+Exi5Kw4onujvi9Pu3zR9lQA8cPKfYj6L74Q');
# Functions for nice-looking terminal output.

package terminal;

use constant black  => "0;0";
use constant red    => "1;31";
use constant yellow => "1;33";
use constant green  => "1;32";
use constant blue   => "1;34";
use constant purple => "1;35";
use constant cyan   => "1;36";

my %default_colors = (info => green);
my $longest_prefix = 0;
$longest_prefix = $longest_prefix < $_ ? $_ : $longest_prefix for map length, keys %default_colors;

sub message {
  my ($prefix, $message) = @_;
  my $color = $default_colors{$prefix};
  my $padding = ' ' x ($longest_prefix - length $prefix);
  print "${padding}[\033[${color}m$prefix\033[0;0m] $message\n";
}
__bakqo5o+Exi5Kw4onujvi9Pu3zR9lQA8cPKfYj6L74Q

meta::sh('js', <<'__qGEHHjKcAKXQz3fhJNhOtnWH3pjzV5E13Ndz4KxZrvs');
js __code__
__qGEHHjKcAKXQz3fhJNhOtnWH3pjzV5E13Ndz4KxZrvs

meta::sh('node', <<'__SSgRGyOQPbEleu+2TMjU4OCmMnjOWFSaJj0iwGkBsug');
node __code__
__SSgRGyOQPbEleu+2TMjU4OCmMnjOWFSaJj0iwGkBsug

meta::sh('node-repl', <<'__q9vTbSQ20/rHKteKvyoqfWOUHbXPrRXR8WvCi2vaMDY');
node-repl __code__
__q9vTbSQ20/rHKteKvyoqfWOUHbXPrRXR8WvCi2vaMDY

meta::sh('repl', <<'__hpfIOvOFVwSLotcBcirerUZLwIeNISkgfqy8K01Nbk8');
js -f __code__ -f -
__hpfIOvOFVwSLotcBcirerUZLwIeNISkgfqy8K01Nbk8

meta::sh('stats', <<'__e/Rj98I2/T+yRRdecrhlw5H3dWmBW2Vup15b2cbzKLg');
echo $(cat __code__ | grep -v '//' | grep -v '^\s*$' | wc -l) LOC, \
     $(cat __code__ | grep '//' | wc -l) comment lines, \
     $(cat __code__ | grep '^\s*$' | wc -l) whitespace lines
__e/Rj98I2/T+yRRdecrhlw5H3dWmBW2Vup15b2cbzKLg

meta::vim_highlighter('ljs', <<'__EELq7R8BHu1htK8/oKRUrIUWVVYqdfaJgsvdyUimtss');
" Literate JavaScript | Spencer Tipping <spencer@spencertipping.com>

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn include @javascript syntax/javascript.vim

syn match ljsGetDirective /::\s*get\s.*$/     contained
syn cluster directives add=ljsGetDirective

syn case match
syn region lCodeRegion    start=/^\s*[\/!0-9a-z_()\[\]{}'"]/   end=/^$/ contains=@javascript transparent fold
syn region lCommentRegion start=/^\s*[^\/!0-9a-z_()\[\]{}'" ]/ end=/^$/ contains=@directives fold

hi link lCommentRegion  comment
hi link ljsGetDirective special

set foldmethod=syntax

let b:current_syntax = "ljs"
__EELq7R8BHu1htK8/oKRUrIUWVVYqdfaJgsvdyUimtss

meta::internal('runtime', <<'__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ');
my $initial_state = sha256_base64 serialize();

push @script_args, shift @ARGV while @ARGV && $ARGV[0] =~ /^-/;

my $default_action = retrieve('data::default-action');
chomp $default_action;
my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};
my $result = &{$function_name}(@ARGV);
chomp $result;
print "$result\n" if $result;

END {
  my $serialized_data = serialize();
  my $final_state     = sha256_base64 $serialized_data;
  save() unless $initial_state eq $final_state;
}

__YPmIzwZkTg8URmPfjiwGRG4VDUF2ZCJqTEz+gjETYLQ

__END__