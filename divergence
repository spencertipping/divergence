#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result;
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name");
};

meta::meta('configure', <<'__25976e07665878d3fae18f050160343f');
# A function to configure transients. Transients can be used to store any number of
# different things, but one of the more common usages is type descriptors.

sub meta::configure {
  my ($datatype, %options) = @_;
  $transient{$_}{$datatype} = $options{$_} for keys %options;
}
__25976e07665878d3fae18f050160343f

meta::meta('externalize', <<'__9141b4e8752515391385516ae94b23b5');
# Function externalization. Data types should call this method when defining a function
# that has an external interface.

sub meta::externalize {
  my ($name, $attribute, $implementation) = @_;
  $externalized_functions{$name} = $attribute;
  *{"::$name"} = $implementation || $attribute;
}
__9141b4e8752515391385516ae94b23b5

meta::meta('externalize_template', <<'__1e90e7ccb5fea1d498bbaaa6e7e43851');
sub meta::externalize_template {
  my ($name, $implementation) = @_;
  meta::externalize "template::$name", "template::$name", $implementation;
}
__1e90e7ccb5fea1d498bbaaa6e7e43851

meta::meta('functor::code-templates', <<'__8438e73e45c87188c8b46d0c43eb4971');
package code;

# Templates for generating named source files.
sub template {
  my ($name, $implementation) = @_;
  $implementation ||= sub {
    my ($line, $block) = @_;
    my $append         = $line =~ s/^\h*>>\h*//o;

    $line =~ s/\s+.*$//o;
    file::write(&{'::source-directory'}() . "/$line", ($append && "\n") . $block, mkpath => 1, append => $append);
    "\\lstset{caption={$line" . ($append && ' (continued)') . "},name={$line}}\\begin{${name}code}\n$block \\end{${name}code}";
  };

  meta::externalize_template $name, $implementation;
}
__8438e73e45c87188c8b46d0c43eb4971

meta::meta('functor::editable', <<'__e97984f7c34d9f06173be574e28c3f91');
# An editable type. This creates a type whose default action is to open an editor
# on whichever value is mentioned. This can be changed using different flags.

sub meta::functor::editable {
  my ($typename, %options) = @_;

  meta::configure $typename, %options;
  meta::define_form $typename, sub {
    my ($name, $value) = @_;

    $options{on_bind} && &{$options{on_bind}}($name, $value);

    meta::externalize $options{prefix} . $name, "${typename}::$name", sub {
      my $attribute             = "${typename}::$name";
      my ($command, @new_value) = @_;

      return edit($attribute)                                                              if $command eq 'edit'                      or $options{default} eq 'edit'   and not defined $command;
      return associate($attribute, @new_value ? join(' ', @new_value) : join('', <STDIN>)) if $command eq '=' or $command eq 'import' or $options{default} eq 'import' and not defined $command;
      return preprocess(retrieve($attribute))                                              if $command eq 'compile'                   or $options{preprocess}          and not defined $command;
      return retrieve($attribute);
    };
  };
}
__e97984f7c34d9f06173be574e28c3f91

meta::meta('functor::tex-templates', <<'__34a5da8558897a4388fc22ed4b0c3c6b');
package tex;

# A wrapper for TeX templates. The idea is always the same, so I'm abstracting out the
# common externalization logic here.
sub template_for(&) {
  my ($implementation) = @_;
  sub {
    my %names = @_;
    for my $name (keys %names) {
      ::meta::externalize_template $name, sub {
        &$implementation($names{$name}, @_);
      };
    }
  };
}

sub id {
  map {$_ => $_} @_;
}

# Creates a one-line or multiline template based on normal TeX syntax. It's a straight
# transfer into TeX with no preprocessing.
*template = template_for {
  my ($name, $line, $block) = @_;
  $block ? "\\begin{$name}\n$block\n\\end{$name}" : "\\$name\{$line\}";
};

# Creates a labeled one-line template. This is just like normal TeX, but assumes the
# specification of a label name after a pipe character.
*labeled_template = template_for {
  my ($name, $line, undef) = @_;
  my ($real_stuff, $label) = split /\h*\|\h*/, $line;
  "\\$name\{$real_stuff\}" . ($label && "\\label{$label}");
};
__34a5da8558897a4388fc22ed4b0c3c6b

meta::meta('internal::runtime', <<'__0172b18c9b9311477d2f6b8c16bb44c2');
meta::configure 'internal', extension => '.pl', inherit => 1;
meta::define_form 'internal', \&meta::meta::implementation;
__0172b18c9b9311477d2f6b8c16bb44c2

meta::meta('template::code', 'code::template $_ for qw/java cpp asm javascript html resource/;');
meta::meta('template::document', 'tex::template tex::id(qw/document tableofcontents maketitle title author date abstract documentclass verbatim/);');
meta::meta('template::enumeration', 'tex::template tex::id(qw/enumerate itemize item/);');
meta::meta('template::math', "tex::template align => 'align*', nalign => 'align';");
meta::meta('template::sections', <<'__0bf14cbc6a0e77d9b82dd185d8d8a9a0');
tex::labeled_template(s1 => 'section', s2 => 'subsection', s3 => 'subsubsection', s4 => 'paragraph', s5 => 'subparagraph');
tex::labeled_template(sc => 'chapter', sp => 'part');
__0bf14cbc6a0e77d9b82dd185d8d8a9a0

meta::meta('type::bootstrap', <<'__297d03fb32df03b46ea418469fc4e49e');
# Bootstrap attributes don't get executed. The reason for this is that because
# they are serialized directly into the header of the file (and later duplicated
# as regular data attributes), they will have already been executed when the
# file is loaded.

meta::configure 'bootstrap', extension => '.pl', inherit => 1;
meta::define_form 'bootstrap', sub {};
__297d03fb32df03b46ea418469fc4e49e

meta::meta('type::data', "meta::functor::editable 'data', extension => '', inherit => 0, default => 'cat';");
meta::meta('type::function', <<'__d93b3cc15693707dac518e3d6b1f5648');
meta::configure 'function', extension => '.pl', inherit => 1;
meta::define_form 'function', sub {
  my ($name, $value) = @_;
  meta::externalize $name, "function::$name", meta::eval_in("sub {\n$value\n}", "function::$name");
};
__d93b3cc15693707dac518e3d6b1f5648

meta::meta('type::internal_function', <<'__34abb44c67c7e282569e28ef6f4d62ab');
meta::configure 'internal_function', extension => '.pl', inherit => 1;
meta::define_form 'internal_function', sub {
  my ($name, $value) = @_;
  *{$name} = meta::eval_in("sub {\n$value\n}", "internal_function::$name");
};
__34abb44c67c7e282569e28ef6f4d62ab

meta::meta('type::library', <<'__a9c0193f297bbc96a78eb5e27727fd30');
meta::configure 'library', extension => '.pl', inherit => 1;
meta::define_form 'library', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "library::$name");
  meta::externalize $name, "library::$name", sub {
    edit("library::$name");
  };
};
__a9c0193f297bbc96a78eb5e27727fd30

meta::meta('type::message_color', <<'__794bf137c425293738f07636bcfb5c55');
meta::configure 'message_color', extension => '', inherit => 1;
meta::define_form 'message_color', sub {
  my ($name, $value) = @_;
  terminal::color($name, $value);
};
__794bf137c425293738f07636bcfb5c55

meta::meta('type::meta', <<'__640f25635ce2365b0648962918cf9932');
# This doesn't define a new type. It customizes the existing 'meta' type
# defined in bootstrap::initialization. Note that horrible things will
# happen if you redefine it using the editable functor.

meta::configure 'meta', extension => '.pl', inherit => 1;
__640f25635ce2365b0648962918cf9932

meta::meta('type::note', "meta::functor::editable 'note', extension => '', inherit => 0, default => 'edit';");
meta::meta('type::resource', "meta::functor::editable 'resource', extension => '.cltex', inherit => 1, default => 'edit';");
meta::meta('type::section', "meta::functor::editable 'section', extension => '.cltex', inherit => 0, default => 'edit';");
meta::meta('type::state', <<'__c1f29670be26f1df6100ffe4334e1202');
# Allows temporary or long-term storage of states. Nothing particularly insightful
# is done about compression, so storing alternative states will cause a large
# increase in size. Also, states don't contain other states -- otherwise the size
# increase would be exponential.

# States are created with the save-state function.

meta::configure 'state', inherit => 0, extension => '.pl';
meta::define_form 'state', \&meta::bootstrap::implementation;
__c1f29670be26f1df6100ffe4334e1202

meta::meta('type::template', <<'__25f4d6eafb1d3eea6d5d3d9a71a5623e');
meta::configure 'template', extension => '.pl', inherit => 1;
meta::define_form 'template', sub {
  my ($name, $value) = @_;
  meta::externalize "template::$name", "template::$name", meta::eval_in("sub {\n$value\n}", "template::$name");
};
__25f4d6eafb1d3eea6d5d3d9a71a5623e

meta::meta('type::vim_highlighter', "meta::functor::editable 'vim_highlighter', extension => '.vim', inherit => 1, default => 'edit';");
meta::meta('type::watch', "meta::functor::editable 'watch', prefix => 'watch::', inherit => 1, extension => '.pl', default => 'cat';");
meta::bootstrap('initialization', <<'__baa43e5e8e6e1cd76d4e2de828ceaa4d');
#!/usr/bin/perl

=head1 Self-modifying Perl script

=head2 Original implementation by Spencer Tipping L<http://spencertipping.com>

The prototype for this script is licensed under the terms of the MIT source code license.
However, this script in particular may be under different licensing terms. To find out how
this script is licensed, please contact whoever sent it to you. Alternatively, you may
run it with the 'license' argument if they have specified a license that way.

You should not edit this file directly. For information about how it was constructed, go
to L<http://spencertipping.com/#section=self-modifying-perl>. For quick usage guidelines, run
this script with the 'usage' argument.
=cut

$|++;

my %data;
my %transient;
my %externalized_functions;
my %datatypes;

my %locations;          # Maps eval-numbers to attribute names

sub meta::define_form {
  my ($namespace, $delegate) = @_;
  $datatypes{$namespace} = $delegate;
  *{"meta::${namespace}::implementation"} = $delegate;
  *{"meta::$namespace"} = sub {
    my ($name, $value) = @_;
    chomp $value;
    $data{"${namespace}::$name"} = $value;
    $delegate->($name, $value);
  };
}

sub meta::eval_in {
  my ($what, $where) = @_;

  # Obtain next eval-number and alias it to the designated location
  @locations{eval('__FILE__') =~ /\(eval (\d+)\)/} = ($where);

  my $result = eval $what;
  $@ =~ s/\(eval \d+\)/$where/ if $@;
  warn $@ if $@;
  $result;
}

meta::define_form 'meta', sub {
  my ($name, $value) = @_;
  meta::eval_in($value, "meta::$name");
};

__baa43e5e8e6e1cd76d4e2de828ceaa4d

meta::data('default-action', 'shell');
meta::data('license', <<'__3c6177256de0fddb721f534c3ad8c0ee');
MIT License
Copyright (c) 2010 Spencer Tipping

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
__3c6177256de0fddb721f534c3ad8c0ee

meta::data('name', 'divergence');
meta::data('output-dir', '/tmp');
meta::data('pdf-output-file', '/tmp/divergence.1e7ca5b951e7539d092daf864a1436b2/document.pdf');
meta::data('pdf-reader', '/usr/bin/evince');
meta::data('pdftex-command', 'pdflatex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__');
meta::data('quiet', '1');
meta::data('source-directory', './src');
meta::data('table-of-contents', '1');
meta::data('tex-command', 'latex -output-directory=__TEMPORARY_DIRECTORY__ __INPUT_FILE__');
meta::data('watching', '0');
meta::function('cat', <<'__c8e76a0cf10e2061e9cf9e1643922c3e');
my ($name) = @_;
$data{$name};
__c8e76a0cf10e2061e9cf9e1643922c3e

meta::function('clean', <<'__1269c1a312062a1598dcde16eb6134e2');
my $output_directory = &{'pdf-output-file'}();
$output_directory =~ s+/.*++g;
unlink <$output_directory/*>;
rmdir $output_directory;
__1269c1a312062a1598dcde16eb6134e2

meta::function('clone', <<'__fec8cf43b197da97cfd5e49d75891d57');
for (@_) {
  if ($_) {
    eval {
      file::write($_, serialize(), noclobber => 1);
      chmod(0700, $_);
      print "File $_ cloned successfully.\n";
    };

    print "$@\n" if $@;
  }
}
__fec8cf43b197da97cfd5e49d75891d57

meta::function('compile', <<'__8de64ff7f4823d92f3258e211608d9bb');
my $tex_command         = &{'tex-command'}();
my $pdftex_command      = &{'pdftex-command'}();
my $filename            = 'document';

my $contents            = tex();
my $output_directory    = &{'output-dir'}();
chomp $output_directory;

my $temporary_directory = state_based_filename();
$temporary_directory =~ s+^.*/++;
$temporary_directory = "$output_directory/$temporary_directory";

$tex_command    =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$tex_command    =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

$pdftex_command =~ s/__TEMPORARY_DIRECTORY__/$temporary_directory/g;
$pdftex_command =~ s+__INPUT_FILE__+$temporary_directory/$filename.tex+g;

mkdir $temporary_directory;
file::write("$temporary_directory/$filename.tex", $contents);

my $result = &{'table-of-contents'}() ? system($tex_command) || system($tex_command) || system($pdftex_command) : system($pdftex_command);

associate('data::pdf-output-file', "$temporary_directory/$filename.pdf", execute => 1);
$result;
__8de64ff7f4823d92f3258e211608d9bb

meta::function('cp', <<'__d33fe9aa270eeee6dcc3ee445447a6a7');
my ($from, $to) = @_;
my $exists = exists $data{$from};
associate($to, retrieve($from)) if $exists;
die "No such attribute $from" unless $exists;
retrieve($from);
__d33fe9aa270eeee6dcc3ee445447a6a7

meta::function('create', <<'__97e5444422f5f6087371f59ddc3e1b8c');
my ($name, $value) = @_;

return edit($name) if exists $data{$name};

if (defined $value) {
  associate($name, $value);
} else {
  associate($name, '');
  edit($name);
}
__97e5444422f5f6087371f59ddc3e1b8c

meta::function('current-state', <<'__0d932bd14547669ffbc86fde3ae9d050');
my @valid_keys   = grep ! /^internal::runtime$/ && ! /^state::/, sort keys %data;
my @ordered_keys = (grep(/^meta::/, @valid_keys), grep(! /^meta::/, @valid_keys));
join "\n", map serialize_single($_), @ordered_keys;
__0d932bd14547669ffbc86fde3ae9d050

meta::function('edit', <<'__6912fb43aad413e79cbf45e134866b6e');
my ($name, %options) = @_;
my $extension = $transient{extension}{namespace($name)} || '';

die "Attribute $name does not exist." unless exists $data{$name};
associate($name, invoke_editor_on($data{$name} || "# Attribute $name", %options, attribute => $name, extension => $extension),
          execute => $name !~ /^internal::/ && $name !~ /^bootstrap::/);
save();
__6912fb43aad413e79cbf45e134866b6e

meta::function('exists', <<'__3c6aa32026f04564ec4861c77a8e6465');
my $name = shift;
grep {$_ eq $name} keys %data;
__3c6aa32026f04564ec4861c77a8e6465

meta::function('export', <<'__6c445eea603f9863df0f8db445fd708e');
# Exports data into a text file.
#   export attr1 attr2 attr3 ... file.txt

my $name = pop @_;
my @attributes = @_;

if (@attributes) {
  my $file = join "\n", map cat($_), @attributes;
  file::write($name, $file);
} else {
  die 'Not enough arguments';
}
__6c445eea603f9863df0f8db445fd708e

meta::function('hash', <<'__7c4145cf6e97dfb9ab04a613866751d3');
my ($data) = @_;
fast_hash($data);
__7c4145cf6e97dfb9ab04a613866751d3

meta::function('import', <<'__84d29edfe7ad2119465fdcf7d037ed1c');
my $name  = pop @_;
my @files = @_;

if (@files) {
  my $files = join "", map {file::read ($_)} @files;
  associate ($name, $files); 
}
else {
  associate($name, join('', <STDIN>));
}
__84d29edfe7ad2119465fdcf7d037ed1c

meta::function('import-bundle', <<'__4c7139ed5c9f65f38a33cf8f8a6cae27');
eval join '', <STDIN>;
die $@ if $@;
__4c7139ed5c9f65f38a33cf8f8a6cae27

meta::function('load-state', <<'__878f141333993ead4d272027ad301eee');
my ($state_name) = @_;
my $state = retrieve("state::$state_name");

terminal::message('state', 'Saving current state into _...');
&{'save-state'}('_');

terminal::message('state', 'Removing attributes from %data and unexternalizing functions...');
delete $data{$_} for grep ! /^state::/ && ! /^internal::runtime$/, keys %data;
%externalized_functions = ();

terminal::message('state', "Restoring state $state_name...");
eval($state);
terminal::message('error', $@) if $@;
reload();
verify();
__878f141333993ead4d272027ad301eee

meta::function('lock', <<'__d94992bf224487f5bfd439eb822db309');
my (undef, undef, $mode) = stat $0;
chmod $mode & 0555, $0;
__d94992bf224487f5bfd439eb822db309

meta::function('ls', <<'__b9d8eab31beedc7e20616be1a37a3c96');
my $criteria   = join('|', @_) || '.';
my @external   = grep /$criteria/, sort keys %externalized_functions;
my @defined_by = map $externalized_functions{$_}, @external;
my @shadows    = grep ! defined $data{$externalized_functions{$_}}, @external;

table_display([@external, @shadows], [@defined_by, map('< shadow >', @shadows)]);
__b9d8eab31beedc7e20616be1a37a3c96

meta::function('ls-a', <<'__15542def52b2c692c8fdb90278493dc2');
my $criteria   = join('|', @_) || '.';
my @attributes = grep(/$criteria/, sort keys %data);
my %inverses   = map {$externalized_functions{$_} => $_} keys %externalized_functions;

table_display([@attributes], [map $inverses{$_}, @attributes], [map sprintf('%6d', length(serialize_single($_))), @attributes],
                                                               [map sprintf('%6d', length(retrieve($_))),         @attributes]);
__15542def52b2c692c8fdb90278493dc2

meta::function('make', <<'__9a3d7e3c7e0017f4c9b239f3858aaf03');
compile() || view();
clean();
__9a3d7e3c7e0017f4c9b239f3858aaf03

meta::function('mv', <<'__09f350db8406303ade06d229477d79ad');
my ($from, $to) = @_;
my $destination_namespace = namespace($to);

die "'$from' does not exist" unless exists $data{$from};
die "The namepsace '$destination_namespace' does not exist" unless $datatypes{$destination_namespace};

associate($to, retrieve($from));
rm($from);
__09f350db8406303ade06d229477d79ad

meta::function('note', <<'__bcbfeac6dd2112f47296265444570a6e');
# Creates a note with a given name, useful for jotting things down.
create("note::$_[0]");
__bcbfeac6dd2112f47296265444570a6e

meta::function('perl', <<'__d8818fd77e9e7ce68811e0947dfcc206');
my $result = eval($_[0]);
$@ ? $@ : $result;
__d8818fd77e9e7ce68811e0947dfcc206

meta::function('pop-state', <<'__90a6d3599a269ca0bef8126df7aba8e0');
%data = %{pop @{$transient{'states'}}} if @{$transient{'states'}};
reload();
__90a6d3599a269ca0bef8126df7aba8e0

meta::function('preprocess', <<'__66e539d29e9afa903569efad0eb7c886');
# Implements a simple preprocessing language.
# Syntax follows two forms. One is the 'line form', which gives you a way to specify arguments inline
# but not spanning multiple lines. The other is 'block form', which gives you access to both one-line
# arguments and a block of lines. The line parameters are passed in verbatim, and the block is
# indentation-adjusted and then passed in as a second parameter. (Indentation is adjusted to align
# with the name of the command.)
#
# Here are the forms:
#
# - line arguments to function
#
# - block line arguments << eof
#   block contents
#   block contents
#   ...
# - eof

my ($string, %options) = @_;
my $expansions         = 0;
my $old_string         = '';
my $limit              = $options{expansion_limit} || 100;
my @pieces             = ();

sub adjust_spaces {
  my ($spaces, $string) = @_;
  $string =~ s/^$spaces  //mg;
  chomp $string;
  $string;
}

while ($old_string ne $string and $expansions++ < $limit) {
  $old_string = $string;

  while ((my @pieces = split  /(^(\h*)-\h \S+ \h* \V* <<\h*(\w+)$ \n .*?  ^\2-\h\3$)/xms, $string) > 1 and $expansions++ < $limit) {
    $pieces[1 + ($_ << 2)] =~ /^ (\h*)-\h(\S+)\h*(\V*)<<\h*(\w+)$ \n(.*?) ^\1-\h\4 $/xms && $externalized_functions{"template::$2"} and
      $pieces[1 + ($_ << 2)] = &{"template::$2"}($3, adjust_spaces($1, $5))
      for 0 .. $#pieces / 4;

    @pieces[2 + ($_ << 2), 3 + ($_ << 2)] = '' for 0 .. $#pieces / 4;
    $string = join '', @pieces;
  }

  if ((my @pieces = split     /^(\h*-\h \S+ \h* .*)$/xom, $string) > 1) {
    $pieces[1 + ($_ << 1)] =~ /^ \h*-\h(\S+)\h*(.*)$/xom && $externalized_functions{"template::$1"} and
      $pieces[1 + ($_ << 1)] = &{"template::$1"}($2)
      for 0 .. $#pieces >> 1;

    $string = join '', @pieces;
  }
}

$string;
__66e539d29e9afa903569efad0eb7c886

meta::function('push-state', <<'__ba601ddf7dce874ce79dd37a936ffdcc');
push @{$transient{'states'} = $transient{'states'} || []}, {%data};
my $state_count = scalar @{$transient{'states'}};
"There are now $state_count states on the stack.";
__ba601ddf7dce874ce79dd37a936ffdcc

meta::function('reload', 'execute($_) for grep ! (/^internal::/ || /^bootstrap::/), keys %data;');
meta::function('render', <<'__ccb26db43115329651cc3c0527a3e849');
use File::Copy 'copy';
compile();
copy(&{'pdf-output-file'}(), &{'source-directory'}() . '/' . name() . '.pdf') or die "Copy failed: $!";
__ccb26db43115329651cc3c0527a3e849

meta::function('rm', <<'__963fdd3d9f6a0ba279b001b1f5679a38');
for my $to_be_deleted (@_) {
  terminal::message('warning', "$to_be_deleted does not exist") unless exists $data{$to_be_deleted};
}

delete @data{@_};
__963fdd3d9f6a0ba279b001b1f5679a38

meta::function('save', <<'__ca9ab587c78ff2024ef9ad8ca634db5b');
if (! verify()) {
  die "$0 has not been updated";
} else {
  my $serialized_data = serialize();
  eval {file::write($0, $serialized_data)};
  die $@ if $@;
  terminal::message('info', "$0 saved successfully.");
}
__ca9ab587c78ff2024ef9ad8ca634db5b

meta::function('save-state', <<'__5c5b586331e25951140ced6442d9fe2b');
# Creates a named copy of the current state and stores it.
my ($state_name) = @_;
associate("state::$state_name", &{'current-state'}(), execute => 1);
__5c5b586331e25951140ced6442d9fe2b

meta::function('serialize', <<'__d7b3affaece3a36d5cfc051b88a5b76e');
my $criteria               = join '|', @_;

my @matching_keys          = grep length && (! $criteria || m/$criteria/), sort keys %data;
my @keys_without_internals = grep ! /^internal::/, @matching_keys;

my @matching_attributes    = map serialize_single($_), grep(/^meta::/,     @keys_without_internals),
                                                       grep(! /^meta::/,   @keys_without_internals),
                                                       grep(/^internal::/, @matching_keys);

my @final_array            = $criteria ? @matching_attributes : (retrieve('bootstrap::initialization'), @matching_attributes, '__END__');

terminal::message('info', "No attributes matched $criteria") unless @final_array;
join "\n", @final_array;
__d7b3affaece3a36d5cfc051b88a5b76e

meta::function('serialize_single', <<'__91663f820a05ff4029a200fbfd7285bc');
# Serializes a single attribute and optimizes for content.

my $name               = $_[0] || $_;
my $contents           = $data{$name};
my $meta_function_name = 'meta::' . namespace($name);
my $invocation_name    = basename($name);

return "$meta_function_name('$invocation_name', '$contents');"   if $contents =~ /^[^\n']*$/;
return "$meta_function_name('$invocation_name', \"$contents\");" if $contents =~ /^[^\n"\\\$@%&]*$/;

my $delimiter = '__' . fast_hash($contents);
return "$meta_function_name('$invocation_name', <<'$delimiter');\n$contents\n$delimiter\n";
__91663f820a05ff4029a200fbfd7285bc

meta::function('shell', <<'__c6ef6c31734c0b330f6076543fef8f1f');
use Term::ReadLine;

my $term = new Term::ReadLine "$0 shell";
$term->ornaments(0);
my $prompt = name() . '$ ';
my $output = $term->OUT || \*STDOUT;

$term->Attribs->{attempted_completion_function} = \&complete;

while (defined ($_ = $term->readline($prompt))) {
  my $command_line = $_;
  my @args = grep length, split /\s+|("[^"\\]*(?:\\.)?")/o;
  my $function_name = shift @args;

  return if $function_name eq 'exit';

  s/^"(.*)"$/\1/o, s/\\\\"/"/go for @args;

  if ($function_name) {
    if ($externalized_functions{$function_name}) {
      chomp(my $result = eval {&$function_name(@args)});
      terminal::message('error', translate_backtrace($@)) if $@;
      print $output $result, "\n" unless $@;
    } else {
      terminal::message('warning', "Command not found: '$function_name' (use 'ls' to see available commands)");
    }
  }

  if (watching()) {
    for (grep /^watch::/, sort keys %data) {
      my $watch = retrieve($_);
      terminal::message('watch', "$_ => " . meta::eval_in($watch, $_));
    }
  }

  $prompt = name() . '$ ';
}
__c6ef6c31734c0b330f6076543fef8f1f

meta::function('size', 'length(serialize());');
meta::function('snapshot', <<'__ccb6335f4837338be1d73ccc5f81973d');
my ($name) = @_;
file::write(my $finalname = state_based_filename($name), serialize(), noclobber => 1);
chmod 0700, $finalname;

terminal::message('state', "Created snapshot at $finalname.");
__ccb6335f4837338be1d73ccc5f81973d

meta::function('state', <<'__e17520e3a5d81d788ae995fd8ac47cb9');
my @keys = sort keys %data;
my $hash = fast_hash(scalar @keys);
$hash = fast_hash($hash . join '|', @keys);
$hash = fast_hash("$data{$_}|$hash") for @keys;
$hash;
__e17520e3a5d81d788ae995fd8ac47cb9

meta::function('tex', <<'__5bb8bf491e1b442858096acf711135f9');
my ($document) = @_;
$document ||= 'main';
preprocess(retrieve("section::$document"));
__5bb8bf491e1b442858096acf711135f9

meta::function('trim', 'wantarray ? map /^\s*(.*?)\s*$/o, @_ : ($_[0] =~ /^\s*(.*?)\s*$/o)[0];');
meta::function('unlock', <<'__b1bdb7eb224487f5bfd439ebb997c823');
my (undef, undef, $mode) = stat $0;
chmod $mode | 0200, $0;
__b1bdb7eb224487f5bfd439ebb997c823

meta::function('update-from', <<'__0b818ed9847d1238b8eaaea8e8c4e581');
# Upgrade all attributes that aren't customized. Customization is defined when the data type is created,
# and we determine it here by checking for $transients{inherit}{$type}.

my $target  = $_[0] or die 'Must specify another script to pull data from.';
my @options = grep /^-/, @_;

&{'save-state'}('before-update');

terminal::message('info', 'Updating meta attributes...');
eval qx($target serialize '^meta::');
terminal::message('warning', $@) if $@;
terminal::message('warning', 'One of the meta-attributes triggered a verification failure.') unless verify();

terminal::message('info', 'Updating non-meta attributes...');
my $combined_pattern = join '|', map "^${_}::", grep ! (/^meta$/ || /^internal$/) && $transient{inherit}{$_}, sort keys %{$transient{inherit}};
eval qx($target serialize '$combined_pattern');
terminal::message('warning', $@) if $@;
reload();

if (verify()) {
  terminal::message('info', "Successfully updated from $_[0]. Run 'load-state before-update' to undo this change.");
} elsif (grep /^--force$/o || /^-f$/o, @options) {
  terminal::message('warning', 'The object failed verification, but the failure state has been kept because --force was specified.');
  terminal::message('warning', 'At this point your object will not save properly, though backup copies will be created.');
  terminal::message('info',    'Run "load-state before-update" to undo the update and return to a working state.');
} else {
  terminal::message('error', 'Verification failed after the upgrade was complete.');
  terminal::message('info',  "$0 has been reverted to its pre-upgrade state.");
  terminal::message('info',  "If you want to upgrade and keep the failure state, then run 'update-from $target --force'.");
  &{'load-state'}('before-update');
}
__0b818ed9847d1238b8eaaea8e8c4e581

meta::function('usage', <<'__234b1da5bb4e34d72a932ab68aad5052');
<<"EOD" . ls ();
Usage: $0 action [arguments]
Defined actions (and the attribute that defines them):
EOD
__234b1da5bb4e34d72a932ab68aad5052

meta::function('verify', <<'__e8ff828f42cdc7d759b70bb81721ddb6');
my $serialized_data = serialize();
my $state           = state();

my $temporary_filename = temporary_name();
$transient{temporary_filename} = $temporary_filename;
file::write($temporary_filename, $serialized_data);
chmod 0700, $temporary_filename;

chomp(my $observed_state = join '', qx|perl '$temporary_filename' state|);

my $result = $observed_state eq $state;
unlink $temporary_filename if $result;
terminal::message('error', "Verification failed; '$observed_state' (produced by $temporary_filename) != '$state' (expected)") unless $result;

$result;
__e8ff828f42cdc7d759b70bb81721ddb6

meta::function('view', <<'__72064117780244bd9dd38659573b9f2c');
my $pdf_reader      = &{'pdf-reader'}();
my $pdf_output_file = &{'pdf-output-file'}();
chomp $pdf_reader;
system("$pdf_reader '$pdf_output_file'");
__72064117780244bd9dd38659573b9f2c

meta::function('vim', <<'__bd231af998c353790253bc6660be0b90');
# Installs VIM highlighters.
file::write("$ENV{'HOME'}/.vim/syntax/$_.vim", retrieve("vim_highlighter::$_")) for grep s/^vim_highlighter:://o, keys %data;
__bd231af998c353790253bc6660be0b90

meta::internal_function('associate', <<'__80f0728190bf3b0d4c94807cfdc12a22');
my ($name, $value, %options) = @_;
my $namespace = namespace($name);
die "Namespace $namespace does not exist" unless $datatypes{$namespace};
$data{$name} = $value;
execute($name) if $options{'execute'};
__80f0728190bf3b0d4c94807cfdc12a22

meta::internal_function('basename', <<'__62efb9f22157835940af1d5feae98d98');
my ($name) = @_;
$name =~ s/^[^:]*:://;
$name;
__62efb9f22157835940af1d5feae98d98

meta::internal_function('complete', <<'__f14ae2337c0653b6bb6fd02bb6493646');
my @functions  = sort keys %externalized_functions;
my @attributes = sort keys %data;

sub match {
  my ($text, @options) = @_;
  my @matches = sort grep /^$text/, @options;

  if    (@matches == 0) {return undef;}
  elsif (@matches == 1) {return $matches [0];}
  elsif (@matches >  1) {return ((longest ($matches [0], $matches [@matches - 1])), @matches);}
}

sub longest {
  my ($s1, $s2) = @_; 
  return substr ($s1, 0, length $1) if ($s1 ^ $s2) =~ /^(\0*)/;
  return ''; 
}

# This is another way to implement autocompletion.
#
# my $attribs = $term->Attribs;
# $attribs->{completion_entry_function} = $attribs->{list_completion_function};
# $attribs->{completion_word} = [sort keys %data, sort keys %externalized_functions];

my ($text, $line) = @_;
if ($line =~ / /) {
  # Start matching attribute names.
  match ($text, @attributes);
} else {
  # Start of line, so it's a function.
  match ($text, @functions);
}
__f14ae2337c0653b6bb6fd02bb6493646

meta::internal_function('debug_trace', <<'__f887289259890731458a66398b628cdc');
quiet() or terminal::message('debug', join ', ', @_);
wantarray ? @_ : $_[0];
__f887289259890731458a66398b628cdc

meta::internal_function('execute', <<'__2d5b6f18c13943d6a0de15e9c348d428');
my ($name, %options) = @_;
my $namespace = namespace($name);
eval {&{"meta::$namespace"}(basename($name), retrieve($name))};
warn $@ if $@ && $options{'carp'};
__2d5b6f18c13943d6a0de15e9c348d428

meta::internal_function('fast_hash', <<'__ac70f469e697725cfb87629833434ab1');
my ($data)     = @_;
my $piece_size = length($data) >> 3;

my @pieces     = (substr($data, $piece_size * 8) . length($data), map(substr($data, $piece_size * $_, $piece_size), 0 .. 7));
my @hashes     = (fnv_hash($pieces[0]));

push @hashes, fnv_hash($pieces[$_ + 1] . $hashes[$_]) for 0 .. 7;

$hashes[$_] ^= $hashes[$_ + 4] >> 16 | ($hashes[$_ + 4] & 0xffff) << 16 for 0 .. 3;
$hashes[0]  ^= $hashes[8];

sprintf '%08x' x 4, @hashes[0 .. 3];
__ac70f469e697725cfb87629833434ab1

meta::internal_function('file::read', <<'__186bbcef8f6f0dd8b72ba0fdeb1de040');
my $name = shift;
open my($handle), "<", $name;
my $result = join "", <$handle>;
close $handle;
$result;
__186bbcef8f6f0dd8b72ba0fdeb1de040

meta::internal_function('file::write', <<'__eb7b1efebe0db73378b0cce46681788d');
use File::Path     'mkpath';
use File::Basename 'dirname';

my ($name, $contents, %options) = @_;
die "Choosing not to overwrite file $name" if $options{noclobber} and -f $name;
mkpath(dirname($name)) if $options{mkpath};

open my($handle), $options{append} ? '>>' : '>', $name or die "Can't open $name for writing";
print $handle $contents;
close $handle;
__eb7b1efebe0db73378b0cce46681788d

meta::internal_function('fnv_hash', <<'__8d001a3a7988631bab21a41cee559758');
# A rough approximation to the Fowler-No Voll hash. It's been 32-bit vectorized
# for efficiency, which may compromise its effectiveness for short strings.

my ($data) = @_;

my ($fnv_prime, $fnv_offset) = (16777619, 2166136261);
my $hash                     = $fnv_offset;
my $modulus                  = 2 ** 32;

$hash = ($hash ^ ($_ & 0xffff) ^ ($_ >> 16)) * $fnv_prime % $modulus for unpack 'L*', $data . substr($data, -4) x 8;
$hash;
__8d001a3a7988631bab21a41cee559758

meta::internal_function('invoke_editor_on', <<'__7c798760d79429e5b52d9fa934e889d8');
my ($data, %options) = @_;
my $editor           = $options{editor} || $ENV{VISUAL} || $ENV{EDITOR} ||
                       die 'Either the $VISUAL or $EDITOR environment variable should be set to a valid editor';
my $options          = $options{options} || $ENV{VISUAL_OPTS} || $ENV{EDITOR_OPTS} || '';
my $extension        = $options{extension} || '';
my $attribute        = $options{attribute} || '';

my $filename         = temporary_name() . "-$attribute" . $extension;

file::write($filename, $data);
system("$editor $options '$filename'");

my $result = file::read($filename);
unlink $filename;
$result;
__7c798760d79429e5b52d9fa934e889d8

meta::internal_function('messages::error', <<'__5af9120535afe26fa6828f477abe833c');
my ($message) = @_;
terminal::message('error', $message);
die;
__5af9120535afe26fa6828f477abe833c

meta::internal_function('messages::warning', <<'__2877a0b67326120f9d43089368e6c4f3');
my ($message) = @_;
terminal::message('warning', $message);
__2877a0b67326120f9d43089368e6c4f3

meta::internal_function('namespace', <<'__93213d60cafb9627e0736b48cd1f0760');
my ($name) = @_;
$name =~ s/::.*$//;
$name;
__93213d60cafb9627e0736b48cd1f0760

meta::internal_function('retrieve', <<'__0e9c1ae91f6cf6020cf1a05db7d51d72');
my @results = map defined $data{$_} ? $data{$_} : file::read($_), @_;
wantarray ? @results : $results[0];
__0e9c1ae91f6cf6020cf1a05db7d51d72

meta::internal_function('state_based_filename', <<'__218815c285975367ae0324bf5c3f5409');
my ($name) = @_;
my $noise  = $name || state();
$noise =~ s/\//-/g;
"$0.$noise";
__218815c285975367ae0324bf5c3f5409

meta::internal_function('table_display', <<'__4ac28dc593ac17fd17b6573c07b43e4e');
# Displays an array of arrays as a table; that is, with alignment. Arrays are
# expected to be in column-major order.

sub maximum_length_in {
  my $maximum = 0;
  length > $maximum and $maximum = length for @_;
  $maximum;
}

my @arrays    = @_;
my @lengths   = map maximum_length_in(@$_), @arrays;
my @row_major = map {my $i = $_; [map $$_[$i], @arrays]} 0 .. $#{$arrays[0]};
my $format    = join '  ', map "%-${_}s", @lengths;

join "\n", map sprintf($format, @$_), @row_major;
__4ac28dc593ac17fd17b6573c07b43e4e

meta::internal_function('temporary_name', <<'__0fb1402061581b69822f913631b4a9d9');
use File::Temp 'tempfile';
my (undef, $temporary_filename) = tempfile("$0." . 'X' x 4, OPEN => 0);
$temporary_filename;
__0fb1402061581b69822f913631b4a9d9

meta::internal_function('translate_backtrace', <<'__06fad3d85833a6484e426401b95e0206');
my ($trace) = @_;
$trace =~ s/\(eval (\d+)\)/$locations{$1 - 1}/g;
$trace;
__06fad3d85833a6484e426401b95e0206

meta::library('terminal', <<'__6999988eaf441c9b1282e03e1db427b5');
# Functions for nice-looking terminal output.
package terminal;

my %color_conversions = (black  => "0;0", red  => "1;31", yellow => "1;33", green => "1;32",
                                          blue => "1;34", purple => "1;35", cyan  => "1;36");
my $longest_prefix = 0;
my %default_colors = ();

sub color {
  $default_colors{$_[0]} = $_[1];
  $longest_prefix = $longest_prefix < length($_[0]) ? length($_[0]) : $longest_prefix;
}

color    'info',  'green';
color  'status',  'green';
color   'error',    'red';
color   'debug',   'blue';
color 'warning', 'yellow';

sub message {
  my ($prefix, $message) = @_;
  my $color = $color_conversions{$default_colors{$prefix}};
  my $padding = ' ' x ($longest_prefix - length $prefix);

  return if ::quiet() and $default_colors{$prefix} eq 'green';
  print STDERR "${padding}\[\033[${color}m$prefix\033[0;0m] $message\n";
}
__6999988eaf441c9b1282e03e1db427b5

meta::message_color('state', 'purple');
meta::message_color('states', 'yellow');
meta::message_color('watch', 'blue');
meta::resource('header', <<'__efe6254be4f73fb4170ab1980a1888d5');
- include resource::header-packages
- include resource::header-listings

- include resource::header-refs

- include resource::header-languages
- include resource::header-resource
__efe6254be4f73fb4170ab1980a1888d5

meta::resource('header-languages', <<'__637a18cf607b727dec3feab552be05e2');
\lstnewenvironment{asmcode}       {}{}
\lstnewenvironment{cppcode}       {\lstset{language=c++}}{}
\lstnewenvironment{javacode}      {\lstset{language=java}}{}
\lstnewenvironment{javascriptcode}{}{}
\lstnewenvironment{htmlcode}      {\lstset{language=html}}{}
__637a18cf607b727dec3feab552be05e2

meta::resource('header-listings', <<'__4caf6ff3ff152cce49ad5d1775ad0703');
\definecolor{gray}{rgb}{0.6,0.6,0.6}

\usepackage{caption}
\DeclareCaptionFormat{listing}{\llap{\color{gray}#1\hspace{10pt}}\tt{}#3}
\captionsetup[lstlisting]{format=listing, singlelinecheck=false, margin=0pt, font={bf}}

\lstset{columns=fixed,basicstyle={\tt},numbers=left,firstnumber=auto,basewidth=0.5em,showstringspaces=false,numberstyle={\color{gray}\scriptsize}}
__4caf6ff3ff152cce49ad5d1775ad0703

meta::resource('header-packages', <<'__f69baadb1d3ce11744003b174c91b34b');
\usepackage[utf8]{inputenc}
\usepackage{amsmath,amssymb,pxfonts,listings,color}
\usepackage[colorlinks]{hyperref}
__f69baadb1d3ce11744003b174c91b34b

meta::resource('header-refs', '\newcommand{\Ref}[2]{\hyperref[#2]{#1 \ref*{#2}}}');
meta::resource('header-resource', '\lstnewenvironment{resourcecode}{}{}');
meta::section('introduction', <<'__a728c2ba97b672e6b54458d51dc60d4a');
- sc Introduction | sec:introduction
  Divergence is a library that constructs functions. It provides customizable tools to build functions from scratch, modify existing functions, and add new language constructs to JavaScript
  using structural preprocessing. This not only makes JavaScript more concise to write, but it also allows for some interesting optimization opportunities.


// Divergence core library | Spencer Tipping <spencer@spencertipping.com>
// Licensed under the terms of the MIT source code license

// See the Divergence guide (http://github.com/spencertipping/divergence-guide) for documentation about the functions here.

// Modified to support CommonJS standard
const d = exports.d = (function (eval_in_global_scope) {
  var c = {}, d = function () {return d[d.default_action].apply (this, arguments)}, gensym_count = 0;
  d.init = function (o) {for (var i = 1, l = arguments.length, $_ = null; $_ = arguments[i], i < l; ++i) if ($_.call && $_.call.apply) $_.call (o);
                                                                                                         else                          for (var k in $_) $_.hasOwnProperty (k) && (o[k] = $_[k]); return o};
  d.init (d, {inline_macros:  [],            id: function    (x) {return x},
                functionals:  [],           arr: function    (o) {return Array.prototype.slice.call (o)},
      functional_extensions:  {},           map: function (o, f) {var x = {}; d.keys (o).each (function (k) {d.init (x, f (k, o[k]) || {})}); return x},
             default_action: 'init',       keys: function    (o) {var xs = []; for (var k in o) o.hasOwnProperty (k) && xs.push (k); return xs},
                                      functions: function     () {var as = d.arr (arguments); return d.functionals.each (function (p) {d.init.apply (this, [p].concat (as))}), d},
                                     functional: function     () {d.arr (arguments).each (function (f) {d.functionals.push (d.init (f, d.functional_extensions))}); return this},
                                         gensym: function    (s) {return 'gensym_' + (s || '') + (++gensym_count).toString(36)},
                                   macro_expand: function    (s) {return d.inline_macros.fold (function (s, m) {return m(s)}, s)},
                                          macro: function (r, f) {d.inline_macros.push (r.maps_to (f)); c = {}; return d},
                                          trace: function    (x) {d.tracer && d.tracer (d.arr (arguments).join (', ')); return x}});

  d (String.prototype, {maps_to: function (v) {var result = {}; result[this] = v; return result},
                         lookup: function  () {return '$0.split(".").fold("$0[$1]", $1)'.fn(this)},
                           fail: function  () {throw new Error (this.toString())},
                             fn: function  () {var s = this.toString(), f = c[s] || (c[s] = eval_in_global_scope ('(function(){return ' + d.macro_expand(s) + '})'));
                                               return f.fn.apply (f, arguments)}});

  d (RegExp.prototype, {maps_to: function (f) {var s = this; return function (x) {return x.replace (s, f)}},
                          macro: function (f) {return d.macro (this, f)},
                             fn: function  () {var f = this.exec.bind (this); return f.fn.apply (f, arguments)}});

  d (Array.prototype, {flat_map: function (f) {var xs = [], f = f.fn(); this.each (function (x) {xs.push.apply (xs, f(x))}); return xs},
                        sort_by: function (f) {return this.sort ('$0($1) < $0($2)'.fn (f.fn()))},
                           each: function (f) {f = f.fn(); for (var i = 0, l = this.length; i < l; ++i) f (this[i]); return this},
                           grep: function (f) {var xs = [], f = f.fn(); for (var i = 0, l = this.length; i < l; ++i) f (this[i]) && xs.push (this[i]); return xs},
                           fold: function (f) {var f = f.fn(), xl = arguments.length, x = xl > 1 ? arguments[1] : this[0];
                                               for (var i = 2, l = xl + this.length; i < l; ++i) x = f (x, i < xl ? arguments[i] : this[i - xl]); return x},
                            map: function (f) {var xs = [], f = f.fn(); for (var i = 0, l = this.length; i < l; ++i) xs.push (f (this[i])); return xs},
                             fn: function  () {var xs = this, f = function () {return xs.map ('$1.fn().apply($_,$0)'.fn (arguments))}; return f.fn.apply (f, arguments)}});

  d (Function.prototype, {fn: function () {var f = this, xs = d.arr (arguments); return xs.length ? function () {return f.apply (this, xs.concat (d.arr (arguments)))} : f}});
  d  (Boolean.prototype, {fn: function () {return Number.prototype.fn.apply (1 - this.valueOf(), arguments)}});
  d   (Number.prototype, {fn: function () {var x = this, f = function () {return arguments[x]}; return f.fn.apply (f, arguments)}});

               /^\./ .macro ('(arguments[0] || this).');
                /@_/g.macro ('Array.prototype.slice.call(arguments)');
               /\$_/g.macro ('this');
           /\$(\d+)/g.macro ('"arguments[" + arguments[1] + "]"'.fn());
            /@(\w+)/g.macro ('"this." + $1'.fn());

  /\{\|([\w,\s]+)\|/g.macro ('"(function(" + $1 + "){return "'.fn()); /\|\}/g.macro ('})');
              /\{\</g.macro ('(function(){return ');                  /\>\}/g.macro ('})');

  (d.functionals = [Array, Number, Boolean, Function, String, RegExp].map ('.prototype')).push (d.functional_extensions);

  d.functions ({
      compose:  function (g) {var f = this.fn(); g = g.fn(); return function () {return f.apply (this, [g.apply (this, arguments)])}},
 flat_compose:  function (g) {var f = this.fn(); g = g.fn(); return function () {return f.apply (this,  g.apply (this, arguments) )}},
        curry:  function (n) {var f = this.fn(); return n > 1 ? function () {var as = d.arr(arguments); return function () {return f.curry (n - 1).apply (this, as.concat (d.arr (arguments)))}} : f},
        proxy:  function (g) {var f = this.fn(); return g ? function () {return f.apply.apply (f, g.fn().apply (this, arguments))} : function () {return f.apply (this, arguments)}},
         bind:  function (x) {var f = this.fn(); return d.init (function () {return f.apply (x, arguments)}, {binding: x, original: f})},
         type:  function  () {var f = function () {}, c = this.fn(); f = f.ctor.apply (f, arguments); return function () {return c.apply (new f(), arguments)}},
         ctor:  function  () {var g = function () {f.apply (this, arguments)}, f = g.original = this.fn(); d.init.apply (this, [g.prototype].concat (d.arr (arguments))); return g},
         tail: '[$_.fn(), arguments]'.fn(),
          cps:  function (c) {var cc = [this.fn(), [c = (c || d.id).fn().proxy()]]; while (cc[0] !== c) cc = cc[0].fn().apply (this, cc[1]); return c.apply (this, cc[1])},
          fix:  function  () {var f = this.fn(); return f (function () {return f.fix().apply (this, arguments)})}});

  return d}) (function () {return eval (arguments[0])});

// Divergence Rebase module | Spencer Tipping <spencer@spencertipping.com>
// Licensed under the terms of the MIT source code license

// Rebase is a Divergence module that takes operator invocations inside functions and rewrites them to be method invocations. Naturally, new meaning can be associated with these constructs; this
// is done by writing methods for them. For example, invocation of the '+' operator is translated into a call to the '+' method. Operator precedence is respected and follows the normal JavaScript
// rules.

// Certain constructs cannot be changed. These include assignment variants such as '+='; such variants are always expanded to their full forms (e.g. a += b becomes a = a + b, which becomes a =
// a['+'](b)). Others include the behavior of 'new', dot-lookups, indexed lookups, function calls, and statement-mode constructs such as 'if', 'for', etc. You can write macros that transform
// these things, but they will have strange limitations and might not behave as expected.

// Since JavaScript is dynamically typed, it isn't possible to know in advance whether an operator overloading replacement will impact a primitive value. This is one reason for the limitations
// described above. The other thing to realize is that those operators need to get replaced for standard things too -- so Number.prototype, String.prototype, and anything else that depends on
// standard operators will have a bunch of replacement functions that delegate to those operators.

// One more thing of importance. Some identifiers are treated specially and sandwiched between operators to form longer operators. They're defined in d.rebase.sandwiches. If an identifier appears
// as a key there (e.g. 'foo'), then it will be sandwiched between binary operators, resulting in the translation of things like 'a + foo + b' as 'a['+foo+'](b)'. This means that you can't use
// 'foo' normally anymore, so use this feature carefully.

(function () {
  var set            = '.fold({< $0[$1] = true, $0 >}, {})'.fn(),            last = '$0[$0.length - 1]'.fn(),  qw = '.split(/\\s+/)'.fn(),
        r = d.rebase =   function  () {return r.init.apply (this, arguments)},  $ = null,
        s            =   function (x) {if (x === undefined || x === null) return ''; var s = x.toString(); return s.charAt(0) === '@' ? s.substring (1) : s};

  d.init (r, {precedence: {'function':1, '[!':1, '.':1, '(!':1, 'new':2, 'u++':3, 'u--':3, '++':3, '--':3, 'typeof':3, 'u~':3, 'u!':3, '!':3, '~':3, 'u+':3, 'u-':3, '*':4, '/':4, '%':4,
                           '+':5, '-':5, '<<':6, '>>':6, '>>>':6, '<':7, '>':7, '<=':7, '>=':7, 'instanceof':7, 'in':7, '==':8, '!=':8, '===':8, '!==':8, '&':9, '^':10, '|':11, '&&':12,
                           '||':13, '?':14, '=':15, '+=':15, '-=':15, '*=':15, '/=':15, '%=':15, '&=':15, '|=':15, '^=':15, '<<=':15, '>>=':15, '>>>=':15, 'case':16, ':':17, ',':18, 'var':19,
                           'const':19, 'if':19, 'while':19, 'for':19, 'do':19, 'switch':19, 'return':19, 'throw':19, 'delete':19, 'export':19, 'import':19, 'try':19, 'catch':19, 'finally':19, 'void':19,
                           'with':19, 'else':19, '?:':20, ';':21, '{':22, '(':22, '[':22},

                   unary: set(qw('u++ u-- ++ -- u+ u- u! u~ new typeof var const case try finally throw return case else delete void import export ( [ { ?:')),
               syntactic: set(qw('case var const if while for do switch return throw delete export import try catch finally void with else function new typeof in instanceof')),
               statement: set(qw('case var const if while for do switch return throw delete export import try catch finally void with else')),
               connected: set(qw('else catch finally')),                                                                       digit: set('0123456789.'.split('')),
                   ident: set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_'.split ('')),                  punct: set('+-*/%&|^!~=<>?:;.,'.split ('')),
                   right: set(qw('= += -= *= /= %= &= ^= |= <<= >>= >>>= u~ u! new typeof u+ u- u++ u-- ++ -- ?')),          openers: {'(':')', '[':']', '{':'}', '?':':'},
     implicit_assignment: set(qw('++ -- u++ u--')),                                                                       sandwiches: set(qw('$ $$ $$$ _ __ ___ _$ _$$ __$')),
                 literal: set(qw('= ++ -- u++ u-- (! [! . ?: , ? u! ( { [ === !== == != ; : && ||')),                   sandwich_ops: set(qw('+ - * / % ^ | & << >> >>> < >')),
           prefix_binary: set(qw('if function catch for switch with while')),                                                closers: {')':'(', ']':'[', '}':'{', ':':'?:'},
            translations: {'u+':'+', 'u-':'-', 'u~':'~', 'u!':'!', 'u--':'--', 'u++':'++'},                                 arity_of: '$0.unary[$1] ? 1 : $1 == "?" ? 3 : 2'.fn(r),
           lvalue_assign: set(qw('+= -= *= /= %= ^= |= &= <<= >>= >>>=')),                                            should_convert: '! ($0.literal[$1] || $0.syntactic[$1])'.fn(r),
               no_spaces: set(qw('.')),

                alias_in: '$0.init ($1, $0.map ($2, {|h, k, v| k.maps_to (h[v] || v.fn()) |}.fn($1)))'.fn(d),

                    init: '$0.deparse($0.transform($0.parse($1)))'.fn(r),
                   local: '$0.transform($0.parse($1)).toString()'.fn(r),

//   Deparsing.
//   This is certainly the easiest part. All we have to do is follow some straightforward rules about how operators and such get serialized. Luckily this is all encapsulated into the toString
//   logic of the syntax tree.

                 deparse: 'eval($0.trace ? $0.trace ($1.toString()) : $1.toString())'.fn(r),

//   Tree transformation.
//   The goal here is to transform the tree in logical form before serializing it to a final function. The way I've chosen to go about this is to use a macro table and deep-map over the syntax
//   tree. Each node gets inspected, and mapping functions can modify nodes by returning alternative values. To save space and time, I'm having macros replace structures halfway destructively
//   rather than using a pure functional approach.

               translate: '$0.transform($0.parse($1)).toString()'.fn(r),
               transform: function (t) {if (t && t.op == '(!' && t.xs[0] == 'literal') return t.xs[1];
                                        var mapped = r.macros.fold ('$1($0) || $0', t);
                                        mapped && mapped.xs && (mapped.xs = mapped.xs.map ('$1 ? $0($1) : $1'.fn (r.transform)));
                                        return mapped},

//   Lexing.
//   The lexer is for the most part straightforward. The only tricky bit is regular expression parsing, which requires the lexer to contextualize operators and operands. I've implemented this
//   logic with a expect_re flag that indicates whether the last token processed was an operator (if so, then we're expecting an operand and the next / delineates a regular expression).

//   We mark the position before a token and then just increment the position. The token, then, can be retrieved by taking a substring from the mark to the position. This eliminates the need for
//   intermediate concatenations. In a couple of cases I've gone ahead and done them anyway -- these are for operators, where we grab the longest contiguous substring that is defined. I'm not to
//   worried about the O(n^2) complexity due to concatenation; they're bounded by four characters.

//   Retrieving the Cartesian coordinates of the token is not difficult provided that we have a list of line lengths. We can then convert that list to a cumulative measure to enable binary
//   searching. I realize this is more elaborate than necessary given that the lexer is streaming (and thus would never need to recover old line lengths), but having to keep track of each newline
//   that occurs while reading the input is probably more expensive than the overhead incurred by O(log n) jumps every so often.

                   parse: function (s) {var mark = 0, s = s.toString(), i = 0, $_ = '', l = s.length, token = '', expect_re = true, escaped = false, t = new r.syntax(null, '('),
                                                      c = s.charAt.bind (s), openers = [],
                                             precedence = r.precedence, ident = r.ident, punct = r.punct, digit = r.digit,
                                            line_breaks = [0].concat (s.split('\n').map('.length')), lb = 1,
                                          located_token = function () {var jump = lb << 1, l = 0, r = new String (token);
                                                                       while (jump >>= 1) mark >= line_breaks[l + jump] && (l += jump);
                                                                       return r.line = l + 1, r.character = mark - line_breaks[l], r};
                          while ((lb <<= 1) < line_breaks.length);
                          for (var j = 0, lj = line_breaks.length, total = -1; j < lj; ++j) line_breaks[j] = total += line_breaks[j] + 1;

                          while ((mark = i) < l && ($_ = c(i))) {
          escaped = token = '';

               if                                (' \n\r\t'.indexOf ($_) > -1)                                                             {++i; continue}
          else if                               ('([{?:}])'.indexOf ($_) > -1)                                                              expect_re = '([{:?'.indexOf ($_) > -1, ++i;
          else if                 ($_ === '/' && c(i + 1) === '*' && (i += 2)) {while       (c(++i) !== '/' || c(i - 1) !== '*' || ! ++i);  continue}
          else if                             ($_ === '/' && c(i + 1) === '/') {while             (($_ = c(++i)) !== '\n' && $_ !== '\r');  continue}
          else if ($_ === '/' && expect_re && ! (expect_re = ! (token = '/'))) {while                  (($_ = c(++i)) !== '/' || escaped)   escaped = ! escaped && $_ === '\\';
                                                                                while                                     (ident[c(++i)]);}
          else if              ($_ === '"' && ! (expect_re = ! (token = '"')))  while         (($_ = c(++i)) !== '"' || escaped || ! ++i)   escaped = ! escaped && $_ === '\\';
          else if              ($_ === "'" && ! (expect_re = ! (token = "'")))  while         (($_ = c(++i)) !== "'" || escaped || ! ++i)   escaped = ! escaped && $_ === '\\';
          else if                    (expect_re && punct[$_] && (token = 'u'))  while        (punct[$_ = c(i)] && precedence[token + $_])   token += $_, ++i;
          else if                            (punct[$_] && (expect_re = true))  while        (punct[$_ = c(i)] && precedence[token + $_])   token += $_, ++i;
          else                                                                 {while (ident[$_ = c(++i)] || digit[c(mark)] && digit[$_]);  expect_re = precedence.hasOwnProperty (token = s.substring (mark, i))}

          expect_re && token.charAt(0) === 'u' || (token = s.substring (mark, i));
          token in {} && (token = '@' + token);

               if         (t.is_value() && '[('.indexOf (token) > -1)  openers.push (t = t.push_op (token + '!').graft (located_token()));
          else if (($_ = r.closers[token]) && last(openers).op == $_)  t = openers.pop().parent, token === '}' && t.is_value() && r.statement[t.op] && (t = t.push_op(';'));
          else if                                     (token === '?')  openers.push (t = t.push_op (located_token()).graft ('?:'));
          else if                                  (r.openers[token])  openers.push (t = t.graft (located_token()));
          else if                                 (precedence[token])  t = t.push_op (located_token());
          else                                                         t.push_value (located_token());
                          }
                          return t.top()},

//   Incremental parsing.
//   As tokens are read from the lexer they are written into a parse tree. Unlike a traditional grammar with productions, this parse tree works in terms of operators and values. Each element in
//   the text is considered to have a certain precedence and to comprise part of an expression. This leads to a weird model and a much more general grammar than JavaScript's, but this is
//   acceptable because we know that by the time we see the code it will be valid.

//   The mechanics of this parser are fairly simple. We build a tree incrementally and include explicit nodes for parentheses (the role of these nodes will become apparent). Starting with the
//   root node, which has no particular identity, we add expressions and operators to this tree. The rules for this are:

//     | 1. When we add an expression to a tree, it is just added to the operand list. This will throw an error if there are too many operands.
//     | 2. When we add an operator to a tree, we check the precedence. If the new operator binds first, then it is added as a child, given a value, and returned. Otherwise we add it to the
//          parent.

                  syntax: '@parent = $0, @op = $1, @xs = $2 || [], $_'.ctor ({
                           is_value: '@xs.length >= $0.arity_of(@op)'.fn(r),
                                map: 'new $0.syntax(null, @op, @xs.map($1).map({|t, x| x.parent = t, x |}.fn($_)))'.fn(r),
                               find: '(@op == $0 || @xs.grep({|t, x| t == x |}.fn($0)).length ? [$_] : []).concat (@xs.flat_map({|t, v| v && v.xs && v.find(t) || [] |}.fn($0)))'.fn(),
                            replace: '@xs[$0] = $1, $1 && ($1.parent = $_), $_'.fn(),
                         push_value: '! @is_value() ? (@xs.push($0), $0) : ("The token " + $0 + " is one too many for the tree " + $_ + " in the context " + $_.top() + ".").fail()'.fn(),
                          with_node: '$0 && ($0.parent = $_), @push_value($0), $_'.fn(),
                            push_op: '$0.precedence[$1] - !! ($0.right[$1] || $0.syntactic[$1]) < $0.precedence[@op] ? @graft($1) : @hand_to_parent($1)'.fn(r),
                              graft: '@push_value(@is_value() ? new $0.syntax($_, $1).with_node(@xs.pop()) : new $0.syntax($_, $1))'.fn(r),
                     hand_to_parent: '@parent ? @parent.push_op($0) : ("Syntax trees should have a minimal-precedence container when parsing " + $0 + " at " + $_).fail()'.fn(),
                                top: '@parent ? @parent.top() : $_'.fn(),
                           toString:  function () {var left_in = function (x, ops) {return x.xs && x.xs[0] && (ops[x.xs[0].op] && x.xs[0].op ||
                                                                                                               x.xs[0].xs && x.xs[0].xs[1] && ops[x.xs[0].xs[1].op] && x.xs[0].xs[1].op)},
                                                      right_in = function (x, ops) {return x.xs && x.xs[1] && ops[x.xs[1].op] && x.xs[1].op},
                                                            $_ = '';
                                                   return '([{'.indexOf(this.op) > -1 ? this.op + s(this.xs[0]) + r.openers[this.op] :
                                                                      this.op ==  '?' ? s(this.xs[0]) + ' ? ' + s(this.xs[1].xs[0]) + ' : ' + s(this.xs[2]) :
                                                   this.op == '(!' || this.op == '[!' ? s(this.xs[0]) + s(this.xs[1]) :
                                                       r.implicit_assignment[this.op] ? '(' + (this.op.charAt(0) === 'u' ? this.op.substring(1) + s(this.xs[0]) : s(this.xs[0]) + this.op) + ')' :
                                             this.xs[1] && r.connected[this.xs[1].op] ? (($_ = s(this.xs[0])).charAt($_.length - 1) === '}' ? $_ + ' ' : $_ + ';') + s(this.xs[1]) :
                                                                     r.unary[this.op] ? (r.translations[this.op] || this.op) + ' ' + s(this.xs[0]) :
                                                             r.prefix_binary[this.op] ? this.op + ' ' + s(this.xs[0]) + ' ' + s(this.xs[1]) :
                                                                 r.no_spaces[this.op] ? s(this.xs[0]) + this.op + s(this.xs[1]) :
                                                                                        s(this.xs[0]) + ' ' + this.op + ' ' + s(this.xs[1])}}),

//   Macro support.
//   Macros are just functions from syntax to syntax. They should behave as the identity if they don't apply to something.

                  macros: [

//     Identifier sandwiching.
//     Certain identifiers can be sandwiched into binary operators as if they were part of the operator name. Most binary operators are candidates for sandwiching, and several identifiers are
//     included by default (see the sandwiches hash above). This could be optimized by using in-place rewriting, but using sandwich operators is not terribly common.

          function (e) {return e.xs && r.sandwich_ops[e.op] ?
            e.xs[1] && e.xs[1].op && r.sandwich_ops[e.xs[1].op] && r.sandwiches[e.xs[1].xs[0]] ? new r.syntax(e.parent, e.op + e.xs[1].xs[0] + e.xs[1].op, [e.xs[0], e.xs[1].xs[1]]) :
            e.xs[0] && e.xs[0].op && r.sandwich_ops[e.xs[0].op] && r.sandwiches[e.xs[0].xs[1]] ? new r.syntax(e.parent, e.xs[0].op + e.xs[0].xs[1] + e.op, [e.xs[0].xs[0], e.xs[1]]) :
            e : e},

//     Assignment expansion.
//     Since the left-hand side of +=, -=, etc. must be an lvalue, we can't say something like x['+='](y) and expect anything useful. So instead of overloading the operator, we just replace it with
//     the longhand x = x + y, and let the '+' operator get replaced by the method call.

          function (e) {return e.xs && r.lvalue_assign[e.op] ? new r.syntax(null, "=", [e.xs[0], new r.syntax(null, e.op.substring(0, e.op.length - 1), e.xs)]) : e},

//     Function notation.
//     To alleviate some of the notational overhead of JavaScript's function definitions, I'm using the operator >$> for this purpose. > takes a low precedence, but it's a good idea to
//     parenthesize each side just in case. You can use this operator without parentheses or with (though for multiple parameters you need them):

//       | x >$> x + 1             // valid
//       | (x) >$> x + 1           // valid
//       | (x, y) >$> x + 1        // valid
//       | x, y >$> x + 1          // parses as x, (y >$> x + 1)

//     Note that you can't say this:

//       | () >$> something

//     The reason is that JavaScript's grammar forbids the use of () as an expression. To get around it, you can bind a throwaway variable:

//       | _ >$> something

          function (e) {return e.op == '>$>' ? new r.syntax(e.parent, 'function').with_node (e.xs[0].op == '(' ? e.xs[0] : new r.syntax (null, '(', [e.xs[0]])).
                                                                                  with_node (new r.syntax (null, '{').with_node (new r.syntax (null, 'return').with_node (e.xs[1]))) : e},

//     Function preloading.
//     Since Rebase doesn't provide an expression-mode variable binding syntax (this would be difficult), binding variables becomes a matter of using functions. This has the advantage that you
//     end up with a proper lexical scope too.

//       | x |$> f === f(x)
//       | (x, y) |$> f === f (x, y)

          function (e) {return e.op == '|$>' ? new r.syntax(e.parent, '(!').with_node (e.xs[1]).with_node (e.xs[0].op == '(' ? e.xs[0] : new r.syntax(null, '(').with_node (e.xs[0])) : e},

//     Comments.
//     Structural comments can be useful for removing chunks of code or for getting comments through SpiderMonkey's parse-deparse cycle (SpiderMonkey, and perhaps other JS interpreters, removes
//     comments between evaling and serializing a function). Either way, the syntax is just like literal(), except that the result will be replaced with the value 'undefined' instead of evaluated
//     normally.

          function (e) {return e.op == '(!' && e.xs && e.xs[0] == 'comment' ? 'undefined' : e},

//     String interpolation.
//     One of Ruby and Perl's great features is string interpolation. We can add this to JavaScript quite easily by writing a macro that looks for string nodes and expands them to expressions
//     that build strings. Unfortunately we won't be able to distinguish between single and double-quoted strings because SpiderMonkey converts them all to double-quoted ones.

          function (e) {return e.charAt && '\'"'.indexOf(e.charAt(0)) > -1 && /#\{[^}]+\}/.test(e) ?
                               '(' + e.replace (/#\{([^}]+)\}/g, function (_, code) {return e.charAt(0) + '+(' + r.translate(code.replace(/\\(.)/g, '$1')) + ')+' + e.charAt(0)}) + ')' : e},

//     Operator overloading.
//     Once we're done with all of the preprocessing we can actually replace the operators with method calls. I'm cheating just a bit here; normally you would encase the operation inside a [ node
//     after wrapping it as a string. However, I'm being lazy and making the excuse that maybe later on you want to detect proper method calls from generated ones; so the right-hand side of the
//     [! will not be what you expect; rather, it will be a single string containing the text [">$$>"] (or some other operator).

          function (e) {return e.op && r.should_convert (e.op) ?
            new r.syntax(e.parent, "(!").with_node(new r.syntax(null, "[!", [e.xs[0], '["' + e.op + '"]'])).with_node(new r.syntax(null, '(', [e.xs[1]])) : e}]});

//   Operator compatibility.
//   We want to make sure that the default behavior of all normal operators is preserved. While we're at it we can give them typable names and form combinatory versions as well.

  var translate = '$0[$1] || $1'.fn(r.translations);
  d.operators = {binary: {transforms: {'$0': '"$_" + $0 + "$0"', '$0 + "_fn"': '"{|t, x| t.apply($_,@_)" + $0 + "x.apply($_,@_)|}.fn($_.fn(), $0.fn())"'},
                           operators: {plus:'+', minus:'-', times:'*', over:'/', modulo:'%', lt:'<', gt:'>', le:'<=', ge:'>=', eq:'==', ne:'!=', req:'===', rne:'!==', and:'&&', or:'||', xor:'^',
                                       bitand:'&', bitor:'|', then:',', lshift: '<<', rshift: '>>', rushift: '>>>'}},
                  unary: {transforms: {'$0': '$0($1) + "$_"'.fn(translate), '$0 + "_fn"': '"{|f| " + $0($1) + "f.fn.apply($_,@_)|}.fn($_.fn())"'.fn(translate)},
                           operators: {complement:'u~', negative:'u-', positive:'u+'}}};

  d.map (d.operators, function (_, os) {
    d.map (os.transforms, function (nt, vt) {d.functions (d.map (os.operators, function (n, v) {return d.init (nt.fn()(v).maps_to (vt.fn()(v).fn()), nt.fn()(n).maps_to (vt.fn()(v).fn()))}))})});

  r.alias_in (Array.prototype, {'*':'map', '%':'grep', '+':'concat', '/':'fold', '>>$-':'flat_map'});
              Array.prototype['<<'] = '@push($0), $_'.fn();

  r.alias_in (r.syntax.prototype, {'<<':'with_node', '*':'map'});

//   Divergence inline macro support.
//   Divergence promotes strings into functions with a macro mechanism very similar to the one here. Because of this, we can enable code transformation inside those inline macros, including
//   translating operators into method calls, etc. By default this isn't enabled (primarily so that users of this library have a very easy way to disable operator overloading etc.) but you can
//   enable it like this:

  r.enable_inline_macro = (function (enabled) {return function () {enabled || (enabled = !! d.inline_macros.push ('$0.toString()'.compose (r.transform).compose (r.parse)))}}) (false)}) ();

// Divergence debug module | Spencer Tipping <spencer@spencertipping.com>
// Licensed under the terms of the MIT source code license

// This debug module enables expression-level debugging and tracing for functions. It records history (controlled by history-recording commands) and lets you replay sequences of events or
// systematically search through them. Note that this can be arbitrarily memory-intensive; recording every single expression that goes through a system is an expensive way to debug things. To
// compensate it uses a sliding window that tracks only the last 10000 results. (This can be changed on a per-watcher basis.)

// It also keeps track of expressions that are reached but never evaluated. These are stored in an "unrequited" log, which is separate from the main event log since these events are usually more
// important. The unrequited log is a stack; when it gets an initialization signal an event is pushed, and when an expression is successfully evaluated an event is popped. Expressions that remain
// are erroneous or otherwise unevaluated.

// There is an interesting problem that arises with invasive debugging like this. If you have method calls such as toString(), which are evaluated automatically upon type coercion, then you could
// end up with an infinite loop. The best way around this is to first run the problematic code, logging the results, then deactivate the hook, and finally print the queue. This is less convenient
// than tracing directly, but the advantage is that toString() and any other functions that are run implicitly won't cause the debugger to enter an infinite loop.

d.rebase (function () {
  var t = d.debug = _ >$> d.debug.init (this, arguments), global = this, syn = x >$> new d.rebase.syntax(null, x),
    set = xs >$> xs * '$0.maps_to(true)'.fn() / d.init, qw = s >$> s.split(/\s+/), qs = set.compose(qw);

  d.functions ({traced: function (options) {var f = this.fn(), options = options || {}, tracer = options.tracer || d.trace, name = options.name || 'anonymous', count = 0;
                                            return d.init (function () {var c = ++count;
                                                                        tracer ('#{name} (#{c}) called on #{this} with [#{Array.prototype.slice.call (arguments).join (", ")}]');
                                                                        try       {var result = f.apply (this, arguments); tracer ('#{name} (#{c}) returned #{result}'); return result}
                                                                        catch (e) {tracer ('#{name} (#{c}) threw #{e}'); throw e}},
                                                           {original: f})}});

  d.init (t, {ring_buffer: '@size = $0, @elements = $1 || [], @position = -1'.ctor ({'<<': '@elements[@position = @position + 1 % @size] = $0, $_'.fn(),
                                                                               'to_array': '@elements.slice(@position + 1).concat (@elements.slice(0, @position + 1))'.fn()}),
                 reserved:  qs('break continue default eval'),   first_only: qs('.'),
                     stop:  qs('++ -- u++ u-- new'),            second_only: qs('function catch = : += -= *= /= %= ^= |= &= <<= >>= >>>= in'),
                     skip:  qs('{ ( [ , ; ?: case var const if while for do switch return throw delete export import try finally void with else'),
        protected_resolve:  qs('[! .'),

                    event: '@node = $0, @value = $1, @time = new Date(), @hook = $2'.ctor ({toString: _ >$> (this.is_before_evaluation() ?
                                                                                                              '(#{this.node}) is about to be evaluated' :
                                                                                                              '(#{this.node}) = (#{this.value}) at #{this.time.getTime()}'),
                                                                                is_before_evaluation: _ >$> (this.value === this.hook)}),

                    trace: (p, f) >$> new t.watcher().use_tracing(f && p).annotate (f || p),

                  watcher: (options >$> (this.name       = d.gensym ('hook'),
                                         this.events     = new t.ring_buffer (options && options.event_log_size || 10000),
                                         this.unrequited = [],
                                         this.predicate  = options && options.predicate || (0).fn())).ctor ({

                            use_logging: _ >$> (global[this.name] = this.hook_function (this.log.bind (this)), this),
                            use_tracing: p >$> (this.predicate = p || this.predicate, global[this.name] = this.hook_function (this.trace.bind (this)), this),

                           destroy_hook: function () {delete global[this.name]; this.installed_hook = null; return this},
                          activate_hook: _ >$> (global[this.name] && (global[this.name].active = true),  this),
                        deactivate_hook: _ >$> (global[this.name] && (global[this.name].active = false), this),
                            hook_active: _ >$> (global[this.name] && global[this.name].active),

                          hook_function: destination >$> (this |$> ((w, hook) >$> (hook = (index, value) >$> (hook.active && (
                                                                                                                value === hook ? w.unrequited.push (w.trace_points[index]) : w.unrequited.pop(),
                                                                                                                destination (new t.event (w.trace_points[index], value, hook))),
                                                                                                              value),
                                                                                   hook.active = true,
                                                                                   hook))),

                          annotate_tree: function (v) {global[this.name] || (this.installed_hook = this.use_logging());
                                                       var $_ = this,  trace_points = this.trace_points = this.trace_points || [],
                                                                      annotate_node = (s, v) >$> syn('(') << (syn(',') <<
                                                                                                   (syn('(!') << $_.name << (syn('(') << (syn(',') << trace_points.length << $_.name))) << 
                                                                                                   (syn('(!') << $_.name << (syn('(') << (syn(',') << (trace_points.push(s) - 1) << v)))),
                                                                  annotate_children =     v  >$> (v.xs ? (v.xs * annotate_tree).fold ((x, y) >$> x << y, syn(v.op)) : v),
                                                                      annotate_tree =     v  >$> (! v || t.reserved[v] ? v :
                                                                                                          t.stop[v.op] ? annotate_node(v, v) :
                                                                                                          t.skip[v.op] ? annotate_children(v) :
                                                                                                    t.first_only[v.op] ? syn(v.op) << annotate_tree(v.xs[0]) << v.xs[1] :
                                                                                                   t.second_only[v.op] ? syn(v.op) << v.xs[0] << annotate_tree(v.xs[1]) :
                                                            v.op == '(!' && v.xs[0] && t.protected_resolve[v.xs[0].op] ? annotate_node (v,
                                                                                                                           syn(v.op) << (syn(v.xs[0].op) << annotate_tree(v.xs[0].xs[0]) <<
                                                                                                                                                            v.xs[0].xs[1]) <<
                                                                                                                                        annotate_tree (v.xs[1])) :
                                                                                                                ! v.xs ? /^@?[A-Za-z_$][A-Za-z0-9_$]*$/.test(v) ? annotate_node(v, v) : v :
                                                                                                                         annotate_node (v, annotate_children (v)));
                                                       return annotate_tree (v)},

                               annotate: f >$> d.rebase.deparse (this.annotate_local (f)),
                         annotate_local: f >$> this.annotate_tree (d.rebase.parse (f)).toString(),

                                  trace: e >$> ((this, this.hook_active()) |$> ((t, a) >$> (t.deactivate_hook(), t.predicate(e) && d.trace(e), a && t.activate_hook()))),
                                    log: e >$> (e ? this.events << e : this.events.to_array())})})}) ();
__a728c2ba97b672e6b54458d51dc60d4a

meta::section('main', <<'__3d0c19f8a6fecb845fcccd26002a574a');
- documentclass report
- include resource::header

- title  Divergence
- author Spencer Tipping

- document << end
  - maketitle

  - tableofcontents

  - include section::introduction
- end
__3d0c19f8a6fecb845fcccd26002a574a

meta::template('comment', "'';     # A mechanism for line or block comments.");
meta::template('eval', <<'__7be1d470a07a06c58e971bc7fc24c048');
my $result = eval $_[0];
terminal::message('warning', "Error during template evaluation: $@") if $@;
$result;
__7be1d470a07a06c58e971bc7fc24c048

meta::template('failing_conditional', <<'__b49f2ffe1cfefb36b1eabd7abd7b3bb6');
my ($commands)    = @_;
my $should_return = $commands =~ / if (.*)$/ && ! eval $1;
terminal::message('warning', "eval of template condition failed: $@") if $@;
$should_return;
__b49f2ffe1cfefb36b1eabd7abd7b3bb6

meta::template('include', <<'__e0624844a65ae41e0217dd871fc0dbfb');
my ($commands) = @_;
return '' if template::failing_conditional($commands);
join "\n", map retrieve($_), split /\s+/, $commands;
__e0624844a65ae41e0217dd871fc0dbfb

meta::vim_highlighter('cltex', <<'__5bfc80e1a2ad3bb7cb4f57ff906d71b0');
" Cleaner TeX
" Maintainer: Spencer Tipping <spencer@spencertipping.com>
" Language:   Cleaner TeX (a variant of LaTeX with support for a bunch of embedded languages)

if version < 600
  syntax clear
elseif exists("b:current_syntax")
  finish
endif

syn match   cltEofMarker   /<<\s*\w\+/ contained
syn region  cltLineComment matchgroup=cltCode start=/^\s*- comment / end=/$/ contained
syn match   cltLine        /^\s*- .*$/ contains=cltEofMarker,cltLineComment

syn include @cpp           syntax/cpp.vim        | unlet b:current_syntax
syn include @java          syntax/java.vim       | unlet b:current_syntax
syn include @asm           syntax/asm.vim        | unlet b:current_syntax
syn include @javascript    syntax/javascript.vim | unlet b:current_syntax
syn include @html          syntax/html.vim       | unlet b:current_syntax

syn region  cltCpp         matchgroup=cltCode start=/^\z(\s*\)- cpp .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@cpp
syn region  cltJava        matchgroup=cltCode start=/^\z(\s*\)- java .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@java
syn region  cltAsm         matchgroup=cltCode start=/^\z(\s*\)- asm .*<<\s*\z(\w\+\)$/        end=/^\z1- \z2$/ contains=@asm
syn region  cltJavascript  matchgroup=cltCode start=/^\z(\s*\)- javascript .*<<\s*\z(\w\+\)$/ end=/^\z1- \z2$/ contains=@javascript
syn region  cltHtml        matchgroup=cltCode start=/^\z(\s*\)- html .*<<\s*\z(\w\+\)$/       end=/^\z1- \z2$/ contains=@html
syn region  cltResource    matchgroup=cltCode start=/^\z(\s*\)- resource .*<<\s*\z(\w\+\)$/   end=/^\z1- \z2$/
syn region  cltComment     matchgroup=cltCode start=/^\z(\s*\)- comment .*<<\s*\z(\w\+\)$/    end=/^\z1- \z2$/

syn cluster cltStuff       add=cltCpp,cltJava,cltAsm,cltJavascript,cltHtml,cltResource,cltComment,cltLine

syn region  cltDocument    start=/\%^/ end=/\%$/ contains=@cltStuff

hi link cltLine            Special
hi link cltKeyword         String
hi link cltResource        String
hi link cltEofMarker       String

hi link cltCode            Special
hi link cltDocument        Comment
hi link cltComment         Type
hi link cltLineComment     Type

let b:current_syntax = "cltex"
__5bfc80e1a2ad3bb7cb4f57ff906d71b0

meta::internal('runtime', <<'__487b99b3af6056d1d1c0e00dd4aef707');
my $initial_state        = state();
chomp(my $default_action = retrieve('data::default-action'));

my $function_name = shift(@ARGV) || $default_action || 'usage';
$function_name = 'usage' unless $externalized_functions{$function_name};

chomp(my $result = &$function_name(@ARGV));
print "$result\n" if $result;

END {
  save() unless $initial_state eq state();
}

__487b99b3af6056d1d1c0e00dd4aef707

__END__